/*
* generated by Xtext
*/
package ac.soton.awm.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class AWMGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cProcessesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cProcessesProcessParserRuleCall_0_0 = (RuleCall)cProcessesAssignment_0.eContents().get(0);
		private final Assignment cOutcomesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOutcomesOutcomeParserRuleCall_1_0 = (RuleCall)cOutcomesAssignment_1.eContents().get(0);
		
		//Model:
		//	processes+=Process* outcomes+=Outcome*;
		public ParserRule getRule() { return rule; }

		//processes+=Process* outcomes+=Outcome*
		public Group getGroup() { return cGroup; }

		//processes+=Process*
		public Assignment getProcessesAssignment_0() { return cProcessesAssignment_0; }

		//Process
		public RuleCall getProcessesProcessParserRuleCall_0_0() { return cProcessesProcessParserRuleCall_0_0; }

		//outcomes+=Outcome*
		public Assignment getOutcomesAssignment_1() { return cOutcomesAssignment_1; }

		//Outcome
		public RuleCall getOutcomesOutcomeParserRuleCall_1_0() { return cOutcomesOutcomeParserRuleCall_1_0; }
	}

	public class ProcessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Process");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNamePROCTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInstructionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInstructionsInstructionParserRuleCall_2_0 = (RuleCall)cInstructionsAssignment_2.eContents().get(0);
		
		//Process:
		//	name=PROC ":" instructions+=Instruction*;
		public ParserRule getRule() { return rule; }

		//name=PROC ":" instructions+=Instruction*
		public Group getGroup() { return cGroup; }

		//name=PROC
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//PROC
		public RuleCall getNamePROCTerminalRuleCall_0_0() { return cNamePROCTerminalRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//instructions+=Instruction*
		public Assignment getInstructionsAssignment_2() { return cInstructionsAssignment_2; }

		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_2_0() { return cInstructionsInstructionParserRuleCall_2_0; }
	}

	public class InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Instruction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cLoadParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cStoreParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cDLoadParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cDStoreParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final RuleCall cWaitParserRuleCall_0_4 = (RuleCall)cAlternatives_0.eContents().get(4);
		private final RuleCall cFenceParserRuleCall_0_5 = (RuleCall)cAlternatives_0.eContents().get(5);
		private final RuleCall cCOMMENTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Instruction:
		//	(Load | Store | DLoad | DStore | Wait | Fence) COMMENT?;
		public ParserRule getRule() { return rule; }

		//(Load | Store | DLoad | DStore | Wait | Fence) COMMENT?
		public Group getGroup() { return cGroup; }

		//Load | Store | DLoad | DStore | Wait | Fence
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//Load
		public RuleCall getLoadParserRuleCall_0_0() { return cLoadParserRuleCall_0_0; }

		//Store
		public RuleCall getStoreParserRuleCall_0_1() { return cStoreParserRuleCall_0_1; }

		//DLoad
		public RuleCall getDLoadParserRuleCall_0_2() { return cDLoadParserRuleCall_0_2; }

		//DStore
		public RuleCall getDStoreParserRuleCall_0_3() { return cDStoreParserRuleCall_0_3; }

		//Wait
		public RuleCall getWaitParserRuleCall_0_4() { return cWaitParserRuleCall_0_4; }

		//Fence
		public RuleCall getFenceParserRuleCall_0_5() { return cFenceParserRuleCall_0_5; }

		//COMMENT?
		public RuleCall getCOMMENTTerminalRuleCall_1() { return cCOMMENTTerminalRuleCall_1; }
	}

	public class LoadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Load");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLdKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRegisterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRegisterRegisterParserRuleCall_1_0 = (RuleCall)cRegisterAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAddressAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAddressADDRTerminalRuleCall_3_0 = (RuleCall)cAddressAssignment_3.eContents().get(0);
		
		//Load:
		//	"ld" register=Register "," address=ADDR;
		public ParserRule getRule() { return rule; }

		//"ld" register=Register "," address=ADDR
		public Group getGroup() { return cGroup; }

		//"ld"
		public Keyword getLdKeyword_0() { return cLdKeyword_0; }

		//register=Register
		public Assignment getRegisterAssignment_1() { return cRegisterAssignment_1; }

		//Register
		public RuleCall getRegisterRegisterParserRuleCall_1_0() { return cRegisterRegisterParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//address=ADDR
		public Assignment getAddressAssignment_3() { return cAddressAssignment_3; }

		//ADDR
		public RuleCall getAddressADDRTerminalRuleCall_3_0() { return cAddressADDRTerminalRuleCall_3_0; }
	}

	public class StoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Store");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAddressAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAddressADDRTerminalRuleCall_3_0 = (RuleCall)cAddressAssignment_3.eContents().get(0);
		
		//Store:
		//	"st" value=INT "," address=ADDR;
		public ParserRule getRule() { return rule; }

		//"st" value=INT "," address=ADDR
		public Group getGroup() { return cGroup; }

		//"st"
		public Keyword getStKeyword_0() { return cStKeyword_0; }

		//value=INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//address=ADDR
		public Assignment getAddressAssignment_3() { return cAddressAssignment_3; }

		//ADDR
		public RuleCall getAddressADDRTerminalRuleCall_3_0() { return cAddressADDRTerminalRuleCall_3_0; }
	}

	public class DLoadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DLoad");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cD_ldKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRegisterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRegisterRegisterParserRuleCall_1_0 = (RuleCall)cRegisterAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAddressAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAddressADDRTerminalRuleCall_3_0 = (RuleCall)cAddressAssignment_3.eContents().get(0);
		
		//DLoad:
		//	"d_ld" register=Register "," address=ADDR;
		public ParserRule getRule() { return rule; }

		//"d_ld" register=Register "," address=ADDR
		public Group getGroup() { return cGroup; }

		//"d_ld"
		public Keyword getD_ldKeyword_0() { return cD_ldKeyword_0; }

		//register=Register
		public Assignment getRegisterAssignment_1() { return cRegisterAssignment_1; }

		//Register
		public RuleCall getRegisterRegisterParserRuleCall_1_0() { return cRegisterRegisterParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//address=ADDR
		public Assignment getAddressAssignment_3() { return cAddressAssignment_3; }

		//ADDR
		public RuleCall getAddressADDRTerminalRuleCall_3_0() { return cAddressADDRTerminalRuleCall_3_0; }
	}

	public class DStoreElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DStore");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cD_stKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAddressAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAddressADDRTerminalRuleCall_3_0 = (RuleCall)cAddressAssignment_3.eContents().get(0);
		
		//DStore:
		//	"d_st" value=INT "," address=ADDR;
		public ParserRule getRule() { return rule; }

		//"d_st" value=INT "," address=ADDR
		public Group getGroup() { return cGroup; }

		//"d_st"
		public Keyword getD_stKeyword_0() { return cD_stKeyword_0; }

		//value=INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//address=ADDR
		public Assignment getAddressAssignment_3() { return cAddressAssignment_3; }

		//ADDR
		public RuleCall getAddressADDRTerminalRuleCall_3_0() { return cAddressADDRTerminalRuleCall_3_0; }
	}

	public class WaitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Wait");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWaitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRegisterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRegisterRegisterParserRuleCall_1_0 = (RuleCall)cRegisterAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAddressAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAddressADDRTerminalRuleCall_3_0 = (RuleCall)cAddressAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueINTTerminalRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		
		//Wait:
		//	"wait" register=Register "," address=ADDR "," value=INT;
		public ParserRule getRule() { return rule; }

		//"wait" register=Register "," address=ADDR "," value=INT
		public Group getGroup() { return cGroup; }

		//"wait"
		public Keyword getWaitKeyword_0() { return cWaitKeyword_0; }

		//register=Register
		public Assignment getRegisterAssignment_1() { return cRegisterAssignment_1; }

		//Register
		public RuleCall getRegisterRegisterParserRuleCall_1_0() { return cRegisterRegisterParserRuleCall_1_0; }

		//","
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }

		//address=ADDR
		public Assignment getAddressAssignment_3() { return cAddressAssignment_3; }

		//ADDR
		public RuleCall getAddressADDRTerminalRuleCall_3_0() { return cAddressADDRTerminalRuleCall_3_0; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//value=INT
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_5_0() { return cValueINTTerminalRuleCall_5_0; }
	}

	public class FenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Fence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFenceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Fence:
		//	{Fence} "fence";
		public ParserRule getRule() { return rule; }

		//{Fence} "fence"
		public Group getGroup() { return cGroup; }

		//{Fence}
		public Action getFenceAction_0() { return cFenceAction_0; }

		//"fence"
		public Keyword getFenceKeyword_1() { return cFenceKeyword_1; }
	}

	public class RegisterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Register");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameREGTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Register:
		//	name=REG;
		public ParserRule getRule() { return rule; }

		//name=REG
		public Assignment getNameAssignment() { return cNameAssignment; }

		//REG
		public RuleCall getNameREGTerminalRuleCall_0() { return cNameREGTerminalRuleCall_0; }
	}

	public class OutcomeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Outcome");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOutcomeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cStateParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cCOMMENTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Outcome:
		//	"outcome:" State COMMENT?;
		public ParserRule getRule() { return rule; }

		//"outcome:" State COMMENT?
		public Group getGroup() { return cGroup; }

		//"outcome:"
		public Keyword getOutcomeKeyword_0() { return cOutcomeKeyword_0; }

		//State
		public RuleCall getStateParserRuleCall_1() { return cStateParserRuleCall_1; }

		//COMMENT?
		public RuleCall getCOMMENTTerminalRuleCall_2() { return cCOMMENTTerminalRuleCall_2; }
	}

	public class StateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "State");
		private final RuleCall cImplicationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//State:
		//	Implication;
		public ParserRule getRule() { return rule; }

		//Implication
		public RuleCall getImplicationParserRuleCall() { return cImplicationParserRuleCall; }
	}

	public class ImplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Implication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDisjunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpIMPLYTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightImplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Implication returns State:
		//	Disjunction ({Binary.left=current} op=IMPLY right=Implication)?;
		public ParserRule getRule() { return rule; }

		//Disjunction ({Binary.left=current} op=IMPLY right=Implication)?
		public Group getGroup() { return cGroup; }

		//Disjunction
		public RuleCall getDisjunctionParserRuleCall_0() { return cDisjunctionParserRuleCall_0; }

		//({Binary.left=current} op=IMPLY right=Implication)?
		public Group getGroup_1() { return cGroup_1; }

		//{Binary.left=current}
		public Action getBinaryLeftAction_1_0() { return cBinaryLeftAction_1_0; }

		//op=IMPLY
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//IMPLY
		public RuleCall getOpIMPLYTerminalRuleCall_1_1_0() { return cOpIMPLYTerminalRuleCall_1_1_0; }

		//right=Implication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Implication
		public RuleCall getRightImplicationParserRuleCall_1_2_0() { return cRightImplicationParserRuleCall_1_2_0; }
	}

	public class DisjunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Disjunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConjunctionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpORTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightDisjunctionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Disjunction returns State:
		//	Conjunction ({Binary.left=current} op=OR right=Disjunction)?;
		public ParserRule getRule() { return rule; }

		//Conjunction ({Binary.left=current} op=OR right=Disjunction)?
		public Group getGroup() { return cGroup; }

		//Conjunction
		public RuleCall getConjunctionParserRuleCall_0() { return cConjunctionParserRuleCall_0; }

		//({Binary.left=current} op=OR right=Disjunction)?
		public Group getGroup_1() { return cGroup_1; }

		//{Binary.left=current}
		public Action getBinaryLeftAction_1_0() { return cBinaryLeftAction_1_0; }

		//op=OR
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//OR
		public RuleCall getOpORTerminalRuleCall_1_1_0() { return cOpORTerminalRuleCall_1_1_0; }

		//right=Disjunction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Disjunction
		public RuleCall getRightDisjunctionParserRuleCall_1_2_0() { return cRightDisjunctionParserRuleCall_1_2_0; }
	}

	public class ConjunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Conjunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpANDTerminalRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightConjunctionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Conjunction returns State:
		//	Negation ({Binary.left=current} op=AND right=Conjunction)?;
		public ParserRule getRule() { return rule; }

		//Negation ({Binary.left=current} op=AND right=Conjunction)?
		public Group getGroup() { return cGroup; }

		//Negation
		public RuleCall getNegationParserRuleCall_0() { return cNegationParserRuleCall_0; }

		//({Binary.left=current} op=AND right=Conjunction)?
		public Group getGroup_1() { return cGroup_1; }

		//{Binary.left=current}
		public Action getBinaryLeftAction_1_0() { return cBinaryLeftAction_1_0; }

		//op=AND
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//AND
		public RuleCall getOpANDTerminalRuleCall_1_1_0() { return cOpANDTerminalRuleCall_1_1_0; }

		//right=Conjunction
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Conjunction
		public RuleCall getRightConjunctionParserRuleCall_1_2_0() { return cRightConjunctionParserRuleCall_1_2_0; }
	}

	public class NegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Negation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cNOTTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cNegatedParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Negation returns State:
		//	NOT Negated | Primary;
		public ParserRule getRule() { return rule; }

		//NOT Negated | Primary
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT Negated
		public Group getGroup_0() { return cGroup_0; }

		//NOT
		public RuleCall getNOTTerminalRuleCall_0_0() { return cNOTTerminalRuleCall_0_0; }

		//Negated
		public RuleCall getNegatedParserRuleCall_0_1() { return cNegatedParserRuleCall_0_1; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_1() { return cPrimaryParserRuleCall_1; }
	}

	public class NegatedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Negated");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotPrimaryParserRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		
		//Negated returns State:
		//	{Not} not=Primary;
		public ParserRule getRule() { return rule; }

		//{Not} not=Primary
		public Group getGroup() { return cGroup; }

		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }

		//not=Primary
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }

		//Primary
		public RuleCall getNotPrimaryParserRuleCall_1_0() { return cNotPrimaryParserRuleCall_1_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cStateParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cRegStateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Primary returns State:
		//	"(" State ")" | RegState;
		public ParserRule getRule() { return rule; }

		//"(" State ")" | RegState
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" State ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//State
		public RuleCall getStateParserRuleCall_0_1() { return cStateParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//RegState
		public RuleCall getRegStateParserRuleCall_1() { return cRegStateParserRuleCall_1; }
	}

	public class RegStateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RegState");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRegisterAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cRegisterRegisterCrossReference_0_0 = (CrossReference)cRegisterAssignment_0.eContents().get(0);
		private final RuleCall cRegisterRegisterRQNParserRuleCall_0_0_1 = (RuleCall)cRegisterRegisterCrossReference_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueINTTerminalRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//RegState:
		//	register=[Register|RQN] "=" value=INT;
		public ParserRule getRule() { return rule; }

		//register=[Register|RQN] "=" value=INT
		public Group getGroup() { return cGroup; }

		//register=[Register|RQN]
		public Assignment getRegisterAssignment_0() { return cRegisterAssignment_0; }

		//[Register|RQN]
		public CrossReference getRegisterRegisterCrossReference_0_0() { return cRegisterRegisterCrossReference_0_0; }

		//RQN
		public RuleCall getRegisterRegisterRQNParserRuleCall_0_0_1() { return cRegisterRegisterRQNParserRuleCall_0_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=INT
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_2_0() { return cValueINTTerminalRuleCall_2_0; }
	}

	public class RQNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RQN");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPROCTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cREGTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//RQN:
		//	PROC "." REG;
		public ParserRule getRule() { return rule; }

		//PROC "." REG
		public Group getGroup() { return cGroup; }

		//PROC
		public RuleCall getPROCTerminalRuleCall_0() { return cPROCTerminalRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//REG
		public RuleCall getREGTerminalRuleCall_2() { return cREGTerminalRuleCall_2; }
	}
	
	
	private final ModelElements pModel;
	private final ProcessElements pProcess;
	private final InstructionElements pInstruction;
	private final LoadElements pLoad;
	private final StoreElements pStore;
	private final DLoadElements pDLoad;
	private final DStoreElements pDStore;
	private final WaitElements pWait;
	private final FenceElements pFence;
	private final RegisterElements pRegister;
	private final OutcomeElements pOutcome;
	private final StateElements pState;
	private final ImplicationElements pImplication;
	private final DisjunctionElements pDisjunction;
	private final ConjunctionElements pConjunction;
	private final NegationElements pNegation;
	private final NegatedElements pNegated;
	private final PrimaryElements pPrimary;
	private final RegStateElements pRegState;
	private final RQNElements pRQN;
	private final TerminalRule tIMPLY;
	private final TerminalRule tOR;
	private final TerminalRule tAND;
	private final TerminalRule tNOT;
	private final TerminalRule tPROC;
	private final TerminalRule tREG;
	private final TerminalRule tADDR;
	private final TerminalRule tCOMMENT;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public AWMGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pProcess = new ProcessElements();
		this.pInstruction = new InstructionElements();
		this.pLoad = new LoadElements();
		this.pStore = new StoreElements();
		this.pDLoad = new DLoadElements();
		this.pDStore = new DStoreElements();
		this.pWait = new WaitElements();
		this.pFence = new FenceElements();
		this.pRegister = new RegisterElements();
		this.pOutcome = new OutcomeElements();
		this.pState = new StateElements();
		this.pImplication = new ImplicationElements();
		this.pDisjunction = new DisjunctionElements();
		this.pConjunction = new ConjunctionElements();
		this.pNegation = new NegationElements();
		this.pNegated = new NegatedElements();
		this.pPrimary = new PrimaryElements();
		this.pRegState = new RegStateElements();
		this.pRQN = new RQNElements();
		this.tIMPLY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "IMPLY");
		this.tOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OR");
		this.tAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AND");
		this.tNOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NOT");
		this.tPROC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PROC");
		this.tREG = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REG");
		this.tADDR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ADDR");
		this.tCOMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMENT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ac.soton.awm.AWM".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	processes+=Process* outcomes+=Outcome*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Process:
	//	name=PROC ":" instructions+=Instruction*;
	public ProcessElements getProcessAccess() {
		return pProcess;
	}
	
	public ParserRule getProcessRule() {
		return getProcessAccess().getRule();
	}

	//Instruction:
	//	(Load | Store | DLoad | DStore | Wait | Fence) COMMENT?;
	public InstructionElements getInstructionAccess() {
		return pInstruction;
	}
	
	public ParserRule getInstructionRule() {
		return getInstructionAccess().getRule();
	}

	//Load:
	//	"ld" register=Register "," address=ADDR;
	public LoadElements getLoadAccess() {
		return pLoad;
	}
	
	public ParserRule getLoadRule() {
		return getLoadAccess().getRule();
	}

	//Store:
	//	"st" value=INT "," address=ADDR;
	public StoreElements getStoreAccess() {
		return pStore;
	}
	
	public ParserRule getStoreRule() {
		return getStoreAccess().getRule();
	}

	//DLoad:
	//	"d_ld" register=Register "," address=ADDR;
	public DLoadElements getDLoadAccess() {
		return pDLoad;
	}
	
	public ParserRule getDLoadRule() {
		return getDLoadAccess().getRule();
	}

	//DStore:
	//	"d_st" value=INT "," address=ADDR;
	public DStoreElements getDStoreAccess() {
		return pDStore;
	}
	
	public ParserRule getDStoreRule() {
		return getDStoreAccess().getRule();
	}

	//Wait:
	//	"wait" register=Register "," address=ADDR "," value=INT;
	public WaitElements getWaitAccess() {
		return pWait;
	}
	
	public ParserRule getWaitRule() {
		return getWaitAccess().getRule();
	}

	//Fence:
	//	{Fence} "fence";
	public FenceElements getFenceAccess() {
		return pFence;
	}
	
	public ParserRule getFenceRule() {
		return getFenceAccess().getRule();
	}

	//Register:
	//	name=REG;
	public RegisterElements getRegisterAccess() {
		return pRegister;
	}
	
	public ParserRule getRegisterRule() {
		return getRegisterAccess().getRule();
	}

	//Outcome:
	//	"outcome:" State COMMENT?;
	public OutcomeElements getOutcomeAccess() {
		return pOutcome;
	}
	
	public ParserRule getOutcomeRule() {
		return getOutcomeAccess().getRule();
	}

	//State:
	//	Implication;
	public StateElements getStateAccess() {
		return pState;
	}
	
	public ParserRule getStateRule() {
		return getStateAccess().getRule();
	}

	//Implication returns State:
	//	Disjunction ({Binary.left=current} op=IMPLY right=Implication)?;
	public ImplicationElements getImplicationAccess() {
		return pImplication;
	}
	
	public ParserRule getImplicationRule() {
		return getImplicationAccess().getRule();
	}

	//Disjunction returns State:
	//	Conjunction ({Binary.left=current} op=OR right=Disjunction)?;
	public DisjunctionElements getDisjunctionAccess() {
		return pDisjunction;
	}
	
	public ParserRule getDisjunctionRule() {
		return getDisjunctionAccess().getRule();
	}

	//Conjunction returns State:
	//	Negation ({Binary.left=current} op=AND right=Conjunction)?;
	public ConjunctionElements getConjunctionAccess() {
		return pConjunction;
	}
	
	public ParserRule getConjunctionRule() {
		return getConjunctionAccess().getRule();
	}

	//Negation returns State:
	//	NOT Negated | Primary;
	public NegationElements getNegationAccess() {
		return pNegation;
	}
	
	public ParserRule getNegationRule() {
		return getNegationAccess().getRule();
	}

	//Negated returns State:
	//	{Not} not=Primary;
	public NegatedElements getNegatedAccess() {
		return pNegated;
	}
	
	public ParserRule getNegatedRule() {
		return getNegatedAccess().getRule();
	}

	//Primary returns State:
	//	"(" State ")" | RegState;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//RegState:
	//	register=[Register|RQN] "=" value=INT;
	public RegStateElements getRegStateAccess() {
		return pRegState;
	}
	
	public ParserRule getRegStateRule() {
		return getRegStateAccess().getRule();
	}

	//RQN:
	//	PROC "." REG;
	public RQNElements getRQNAccess() {
		return pRQN;
	}
	
	public ParserRule getRQNRule() {
		return getRQNAccess().getRule();
	}

	//terminal IMPLY:
	//	"=>";
	public TerminalRule getIMPLYRule() {
		return tIMPLY;
	} 

	//terminal OR:
	//	"or";
	public TerminalRule getORRule() {
		return tOR;
	} 

	//terminal AND:
	//	"and";
	public TerminalRule getANDRule() {
		return tAND;
	} 

	//terminal NOT:
	//	"not";
	public TerminalRule getNOTRule() {
		return tNOT;
	} 

	//terminal PROC:
	//	("P" | "p") INT;
	public TerminalRule getPROCRule() {
		return tPROC;
	} 

	//terminal REG:
	//	("R" | "r") INT;
	public TerminalRule getREGRule() {
		return tREG;
	} 

	//terminal ADDR:
	//	("A" | "a") INT;
	public TerminalRule getADDRRule() {
		return tADDR;
	} 

	//terminal COMMENT:
	//	";" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getCOMMENTRule() {
		return tCOMMENT;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
