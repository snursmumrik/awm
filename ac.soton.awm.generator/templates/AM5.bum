<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.comment="A registerfile is introduced for each master which is initialised to V0.&#10;When a load is observed by the master that issued the load, the master's registerfile&#10;takes the master's last observed value for this address" org.eventb.core.configuration="org.eventb.core.fwd" org.eventb.texttools.text_lastmodified="1427703778865" org.eventb.texttools.text_representation="machine AM5&#10;&#10;// A registerfile is introduced for each master which is initialised to V0.&#10;// When a load is observed by the master that issued the load, the master's registerfile&#10;// takes the master's last observed value for this address&#10;&#10;refines AM4 sees AC5&#10;&#10;variables issued observed lastobservedvalue observers ahead behind issuedbarrier registerfile&#10;&#10;invariants&#10;  @inv1 registerfile ∈ MASTER ⇸ (REG → VALUE)  // each master has&#10;  @inv2 ∀m·m ∈ MASTER ⇒ m ∈ dom(registerfile)  // a registerfile&#10;&#10;events&#10;  event INITIALISATION&#10;    then&#10;      @act1 issued ≔ ∅&#10;      @act2 observed ≔ ∅&#10;      @act3 lastobservedvalue ≔ MASTER × {ADDR × {V0}} // initialise each master's view of memory to the default value V0&#10;      @act4 observers ≔ ∅&#10;      @act5 ahead ≔ ∅&#10;      @act6 behind ≔ DMB × {∅}&#10;      @act7 issuedbarrier ≔ ∅&#10;      @act8 registerfile ≔ MASTER × { REG × {V0} }  // initialise the registerfiles to the default value V0&#10;  end&#10;&#10;  event IssueLoad // out of order and the observation of the load is not constrained by a DMB&#10;  refines IssueLoad&#10;    any l&#10;    where&#10;      @grd1 l ∉ issued // not already issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅ // if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {l} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {l ↦ ∅}  // establish the set, initially empty, that will hold the observers of the load&#10;  end&#10;&#10;  event IssueLoadBehindDMB // out of order and the observation of the load is constrained by a DMB&#10;  refines IssueLoadBehindDMB&#10;    any l b&#10;    where&#10;      @grd1 l ∉ issued // not already issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 issuer(b) = issuer(l) // the issuer of the load has issued a barrier&#10;      @grd4 b ∈ dom(ahead) // and there are stores ahead of the barrier which have&#10;      @grd5 ahead(b) ≠ ∅ // not been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {l} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {l ↦ ∅}  // establish the set, initially empty, that will hold the observers of the load&#10;      @act3 behind(b) ≔ behind(b) ∪ {l} // load is added to the set of memory accesses behind the barrier&#10;  end&#10;&#10;  event IssueStore // out of order and the observation of the store is not constrained by a DMB&#10;  refines IssueStore&#10;    any s&#10;    where&#10;      @grd1 s ∉ issued // not already issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅ // if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {s} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {s ↦ ∅} // establish the set, initially empty, that will hold the observers of the store&#10;  end&#10;&#10;  event IssueStoreBehindDMB // out of order and the observation of the store is constrained by a DMB&#10;  refines IssueStoreBehindDMB&#10;    any s b&#10;    where&#10;      @grd1 s ∉ issued // not already issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 issuer(b) = issuer(s) // the issuer of the store has issued a barrier&#10;      @grd4 b ∈ dom(ahead) // and there are stores ahead of the barrier which have&#10;      @grd5 ahead(b) ≠ ∅ // not been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {s} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {s ↦ ∅} // establish the set, initially empty, that will hold the observers of the store&#10;      @act3 behind(b) ≔ behind(b) ∪ {s} // store is added to the set of memory accesses behind the barrier&#10;  end&#10;&#10;  event ObserveLoad // not constrained by a DMB&#10;  refines ObserveLoad&#10;    any l m a&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 ∀b·b ∈ dom(ahead) ⇒ l ∉ ahead(b)  // not ahead of a barrier&#10;      @grd6 ∀b·b ∈ dom(behind) ⇒ l ∉ behind(b) // load is not behind any barrier&#10;      @grd7 a = address(l) // the load address&#10;      @grd8 a ∈ dom(lastobservedvalue(m)) // m has observed a store for this address&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;      @act3 registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)} // load the value of the last observed store for this address&#10;  end&#10;&#10;  event ObserveLoadAheadofDMB // constrained by a DMB - the master issuing the DMB observes loads it has issued before the DMB&#10;  refines ObserveLoadAheadofDMB&#10;    any l m b a&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 l ∈ ahead(b) //  is ahead of the barrier&#10;      @grd7 a = address(l) // the load address&#10;      @grd8 a ∈ dom(lastobservedvalue(m)) // m has observed a store for this address&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;      @act3 ahead(b) ≔ ahead(b) ∖ {l}  // remove load from ahead set&#10;      @act4 registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)} // load the value of the last observed store for this address&#10;  end&#10;&#10;  event ObserveLoadBehindDMB // constrained by a DMB: cannot be observed until all stores ahead of the barrier have been observed&#10;  refines ObserveLoadBehindDMB&#10;    any l b m a&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 b ∈ dom(behind)&#10;      @grd7 l ∈ behind(b) // load is behind a barrier&#10;      @grd8 ahead(b) = ∅ // all stores ahead of the barrier have been observed&#10;      @grd9 a = address(l) // the load address&#10;      @grd10 a ∈ dom(lastobservedvalue(m)) // m has observed a store for this address&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;      @act3 registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)} // load the value of the last observed store for this address&#10;  end&#10;&#10;  event ObserveStore // not constrained by a DMB&#10;  refines ObserveStore&#10;    any s m&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 ∀b·b ∈ dom(ahead) ⇒ s ∉ ahead(b) // not ahead of a barrier&#10;      @grd5 ∀b·b ∈ dom(behind) ⇒ s ∉ behind(b) // not behind a barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m}&#10;  end&#10;&#10;  event ObserveStoreAheadofDMB // constrained by DMB, not all masters have observed the store&#10;  refines ObserveStoreAheadofDMB&#10;    any s m b o&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 s ∈ ahead(b) // s is ahead of the barrier&#10;      @grd6 o ≠ m&#10;      @grd7 o ∉ observers(s) // there is at least one other master that has not observed this store&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;  end&#10;&#10;  event ObserveStoreLoadAheadofDMB // the master that issued the barrier has issued a LOAD ahead of the barrier that follows this store in observe order&#10;  refines ObserveStoreLoadAheadofDMB&#10;    any s m b l&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 l ∈ LOAD&#10;      @grd4 m ∉ observers(s) // the master has not already observed this store&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 s ∉ ahead(b)&#10;      @grd7 l ∈ ahead(b)&#10;      @grd8 address(l) = address(s)  // s is ahead of the barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;      @act4 ahead(b) ≔ ahead(b) ∪ {s}&#10;  end&#10;&#10;  event ObserveStoreAheadofDMBComplete // constrained by DMB, store is observed by the all the masters&#10;  refines ObserveStoreAheadofDMBComplete&#10;    any s m b&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 s ∈ ahead(b) // s is ahead of the barrier&#10;      @grd6 ∀o·o ∈ MASTER ∧ o ≠ m ⇒ o ∈ observers(s) // m is that last master to observe this store&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;      @act4 ahead(b) ≔ ahead(b) ∖ {s} // remove store from ahead set&#10;  end&#10;&#10;  event ObserveStoreBehindDMB // constrained by DMB&#10;  refines ObserveStoreBehindDMB&#10;    any s m b&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 b ∈ dom(behind)&#10;      @grd6 ahead(b) = ∅ // all stores ahead of the barrier have been observed&#10;      @grd7 s ∈ behind(b) // s is behind the barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;  end&#10;&#10;  event issueDMB // a master issues a DMB&#10;  refines issueDMB&#10;    any b m&#10;    where&#10;      @grd1 b ∈ DMB&#10;      @grd2 m ∈ MASTER&#10;      @grd3 m = issuer(b)&#10;      @grd4 b ∉ issuedbarrier&#10;    then&#10;      @act1 ahead ≔ ahead  {b ↦ ({t∣t ∈ issued ∧ m = issuer(t) ∧ m ∉ observers(t)} ∪&#10;                                   {s∣s ∈ dom(observers) ∧ m ∈ observers(s) ∧ (∃o·o ∉ observers(s))})} // all memory accesses issued by the master but not observed, together with all the STOREs observed by the master but not observed by all other observers&#10;      @act2 issuedbarrier ≔ issuedbarrier ∪ {b}&#10;  end&#10;end&#10;" version="5">
<org.eventb.core.refinesMachine name="_mJ_nINatEeS8PrcbdDoUAw" org.eventb.core.target="AM4"/>
<org.eventb.core.seesContext name="_mJ_nIdatEeS8PrcbdDoUAw" org.eventb.core.target="AC5"/>
<org.eventb.core.variable name="(" org.eventb.core.identifier="issued"/>
<org.eventb.core.variable name="_w4qjgLBREeSftfcqDYm3Dx" org.eventb.core.identifier="observed"/>
<org.eventb.core.variable name="_noQRoLBdEeS2YI9ZOZw9XQ" org.eventb.core.identifier="lastobservedvalue"/>
<org.eventb.core.variable name="_38H2UNFaEeSEfrkbRWF-Qw" org.eventb.core.identifier="observers"/>
<org.eventb.core.variable name="_SaT1UrDuEeSDLL1FFCt7mQ" org.eventb.core.identifier="ahead"/>
<org.eventb.core.variable name="_7OyMELD8EeSDLL1FFCt7mQ" org.eventb.core.identifier="behind"/>
<org.eventb.core.variable name="_Kw5kIMyeEeS35eQk3gU39A" org.eventb.core.identifier="issuedbarrier"/>
<org.eventb.core.variable name="_dBTdMLs2EeSbduHSoMvCew" org.eventb.core.identifier="registerfile"/>
<org.eventb.core.invariant name="_dBTdMbs2EeSbduHSoMvCew" org.eventb.core.comment="each master has" org.eventb.core.label="inv1" org.eventb.core.predicate="registerfile ∈ MASTER ⇸ (REG → VALUE)"/>
<org.eventb.core.invariant name="_NeKtMLs7EeSbduHSoMvCew" org.eventb.core.comment="a registerfile" org.eventb.core.label="inv2" org.eventb.core.predicate="∀m·m ∈ MASTER ⇒ m ∈ dom(registerfile)"/>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3Dy" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
<org.eventb.core.action name="'" org.eventb.core.assignment="issued ≔ ∅" org.eventb.core.label="act1"/>
<org.eventb.core.action name="(" org.eventb.core.assignment="observed ≔ ∅" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_noQ4sLBdEeS2YI9ZOZw9XQ" org.eventb.core.assignment="lastobservedvalue ≔ MASTER × {ADDR × {V0}}" org.eventb.core.comment="initialise each master's view of memory to the default value V0" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_lW8g4LBeEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers ≔ ∅" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_SaVDcLDuEeSDLL1FFCt7mQ" org.eventb.core.assignment="ahead ≔ ∅" org.eventb.core.label="act5"/>
<org.eventb.core.action name="_7OyzILD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="behind ≔ DMB × {∅}" org.eventb.core.label="act6"/>
<org.eventb.core.action name="_n2xx8Ls2EeSbduHSoMvCew" org.eventb.core.assignment="issuedbarrier ≔ ∅" org.eventb.core.label="act7"/>
<org.eventb.core.action name="_Kw6yQMyeEeS35eQk3gU39A" org.eventb.core.assignment="registerfile ≔ MASTER × { REG × {V0} }" org.eventb.core.comment="initialise the registerfiles to the default value V0" org.eventb.core.label="act8"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3Dz" org.eventb.core.comment="out of order and the observation of the load is not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueLoad">
<org.eventb.core.refinesEvent name="_mKDRgNatEeS8PrcbdDoUAw" org.eventb.core.target="IssueLoad"/>
<org.eventb.core.parameter name="_6jYTQbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.guard name="_5G8aQ7BWEeSftfcqDYm3Dw" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∉ issued"/>
<org.eventb.core.guard name="_5G9BULBWEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_B5KugLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅"/>
<org.eventb.core.action name="_5G9BUbBWEeSftfcqDYm3Dw" org.eventb.core.assignment="issued ≔ issued ∪ {l}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_38JEcdFaEeSEfrkbRWF-Qw" org.eventb.core.assignment="observers ≔ observers  {l ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the load" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D{" org.eventb.core.comment="out of order and the observation of the load is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueLoadBehindDMB">
<org.eventb.core.refinesEvent name="_mKFGsNatEeS8PrcbdDoUAw" org.eventb.core.target="IssueLoadBehindDMB"/>
<org.eventb.core.parameter name="_6jY6UbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_B5UfgrD_EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_B5Ufg7D_EeSDLL1FFCt7mQ" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∉ issued"/>
<org.eventb.core.guard name="_B5UfhLD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_B5VGkLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the issuer of the load has issued a barrier" org.eventb.core.label="grd3" org.eventb.core.predicate="issuer(b) = issuer(l)"/>
<org.eventb.core.guard name="_B5VGkbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="and there are stores ahead of the barrier which have" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_B5VGkrD_EeSDLL1FFCt7mQ" org.eventb.core.comment="not been observed" org.eventb.core.label="grd5" org.eventb.core.predicate="ahead(b) ≠ ∅"/>
<org.eventb.core.action name="_B5VGk7D_EeSDLL1FFCt7mQ" org.eventb.core.assignment="issued ≔ issued ∪ {l}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_B5VGlLD_EeSDLL1FFCt7mQ" org.eventb.core.assignment="observers ≔ observers  {l ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_38KSkNFaEeSEfrkbRWF-Qw" org.eventb.core.assignment="behind(b) ≔ behind(b) ∪ {l}" org.eventb.core.comment="load is added to the set of memory accesses behind the barrier" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D|" org.eventb.core.comment="out of order and the observation of the store is not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueStore">
<org.eventb.core.refinesEvent name="_mKG74NatEeS8PrcbdDoUAw" org.eventb.core.target="IssueStore"/>
<org.eventb.core.parameter name="_6jaIcbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.guard name="_5G9oYrBWEeSftfcqDYm3Dw" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∉ issued"/>
<org.eventb.core.guard name="_5G9oY7BWEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_jNTeIbD-EeSDLL1FFCt7mQ" org.eventb.core.comment="if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅"/>
<org.eventb.core.action name="_5G9oZLBWEeSftfcqDYm3Dw" org.eventb.core.assignment="issued ≔ issued ∪ {s}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_HHecIbBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers ≔ observers  {s ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the store" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D}" org.eventb.core.comment="out of order and the observation of the store is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueStoreBehindDMB">
<org.eventb.core.refinesEvent name="_mKIKANatEeS8PrcbdDoUAw" org.eventb.core.target="IssueStoreBehindDMB"/>
<org.eventb.core.parameter name="_6javgbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_fyTBwrD8EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_fyTBw7D8EeSDLL1FFCt7mQ" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∉ issued"/>
<org.eventb.core.guard name="_fyTBxLD8EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_fyTo0LD8EeSDLL1FFCt7mQ" org.eventb.core.comment="the issuer of the store has issued a barrier" org.eventb.core.label="grd3" org.eventb.core.predicate="issuer(b) = issuer(s)"/>
<org.eventb.core.guard name="_fyTo0bD8EeSDLL1FFCt7mQ" org.eventb.core.comment="and there are stores ahead of the barrier which have" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_fyTo0rD8EeSDLL1FFCt7mQ" org.eventb.core.comment="not been observed" org.eventb.core.label="grd5" org.eventb.core.predicate="ahead(b) ≠ ∅"/>
<org.eventb.core.action name="_fyTo07D8EeSDLL1FFCt7mQ" org.eventb.core.assignment="issued ≔ issued ∪ {s}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_fyUP4LD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="observers ≔ observers  {s ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the store" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_7O2dgLD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="behind(b) ≔ behind(b) ∪ {s}" org.eventb.core.comment="store is added to the set of memory accesses behind the barrier" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D~" org.eventb.core.comment="not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoad">
<org.eventb.core.refinesEvent name="_mKJ_MNatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoad"/>
<org.eventb.core.parameter name="_6jb9obErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_hRwB4bs6EeSbduHSoMvCew" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_7rFQobs7EeSbduHSoMvCew" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_F9cLkbBXEeSftfcqDYm3Dw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_F9cLkrBXEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_8IdesbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="__Xjk8LHQEeSNlasBfv989A" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_hRwo8Ls6EeSbduHSoMvCew" org.eventb.core.comment="not ahead of a barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ⇒ l ∉ ahead(b)"/>
<org.eventb.core.guard name="_7rGewLs7EeSbduHSoMvCew" org.eventb.core.comment="load is not behind any barrier" org.eventb.core.label="grd6" org.eventb.core.predicate="∀b·b ∈ dom(behind) ⇒ l ∉ behind(b)"/>
<org.eventb.core.guard name="_7rGewbs7EeSbduHSoMvCew" org.eventb.core.comment="the load address" org.eventb.core.label="grd7" org.eventb.core.predicate="a = address(l)"/>
<org.eventb.core.guard name="_CjrssNOREeSWGfl1zVgqXQ" org.eventb.core.comment="m has observed a store for this address" org.eventb.core.label="grd8" org.eventb.core.predicate="a ∈ dom(lastobservedvalue(m))"/>
<org.eventb.core.action name="_F9cyoLBXEeSftfcqDYm3Dw" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_hRxQALs6EeSbduHSoMvCew" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_38MHwNFaEeSEfrkbRWF-Qw" org.eventb.core.assignment="registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)}" org.eventb.core.comment="load the value of the last observed store for this address" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_Cj02oNOREeSWGfl1zVgqXQ" org.eventb.core.comment="constrained by a DMB - the master issuing the DMB observes loads it has issued before the DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoadAheadofDMB">
<org.eventb.core.refinesEvent name="_mKL0YNatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoadAheadofDMB"/>
<org.eventb.core.parameter name="_Cj02otOREeSWGfl1zVgqXQ" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_Cj02o9OREeSWGfl1zVgqXQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_Cj02pNOREeSWGfl1zVgqXQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_Cj02pdOREeSWGfl1zVgqXQ" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_Cj1dsNOREeSWGfl1zVgqXQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_Cj1dsdOREeSWGfl1zVgqXQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_Cj1dstOREeSWGfl1zVgqXQ" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="_Cj1ds9OREeSWGfl1zVgqXQ" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_Cj1dtNOREeSWGfl1zVgqXQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_Cj2EwNOREeSWGfl1zVgqXQ" org.eventb.core.comment="is ahead of the barrier" org.eventb.core.label="grd6" org.eventb.core.predicate="l ∈ ahead(b)"/>
<org.eventb.core.guard name="_Cj2EwdOREeSWGfl1zVgqXQ" org.eventb.core.comment="the load address" org.eventb.core.label="grd7" org.eventb.core.predicate="a = address(l)"/>
<org.eventb.core.guard name="_Cj2EwtOREeSWGfl1zVgqXQ" org.eventb.core.comment="m has observed a store for this address" org.eventb.core.label="grd8" org.eventb.core.predicate="a ∈ dom(lastobservedvalue(m))"/>
<org.eventb.core.action name="_Cj2Ew9OREeSWGfl1zVgqXQ" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_Cj2ExNOREeSWGfl1zVgqXQ" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_Cj2r0NOREeSWGfl1zVgqXQ" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∖ {l}" org.eventb.core.comment="remove load from ahead set" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_Cj2r0dOREeSWGfl1zVgqXQ" org.eventb.core.assignment="registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)}" org.eventb.core.comment="load the value of the last observed store for this address" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E'" org.eventb.core.comment="constrained by a DMB: cannot be observed until all stores ahead of the barrier have been observed" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoadBehindDMB">
<org.eventb.core.refinesEvent name="_mKOQoNatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoadBehindDMB"/>
<org.eventb.core.parameter name="_6jcksbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_8IjlUrD_EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_lDXncLs8EeSbduHSoMvCew" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_lDXncbs8EeSbduHSoMvCew" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_8IjlU7D_EeSDLL1FFCt7mQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_8IjlVLD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_38Mu0dFaEeSEfrkbRWF-Qw" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="_8IkMYbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_8IkMYrD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_8IkMY7D_EeSDLL1FFCt7mQ" org.eventb.core.label="grd6" org.eventb.core.predicate="b ∈ dom(behind)"/>
<org.eventb.core.guard name="_2bFLcLHLEeStFcxm7qdLvQ" org.eventb.core.comment="load is behind a barrier" org.eventb.core.label="grd7" org.eventb.core.predicate="l ∈ behind(b)"/>
<org.eventb.core.guard name="_lDY1kLs8EeSbduHSoMvCew" org.eventb.core.comment="all stores ahead of the barrier have been observed" org.eventb.core.label="grd8" org.eventb.core.predicate="ahead(b) = ∅"/>
<org.eventb.core.guard name="_lDY1kbs8EeSbduHSoMvCew" org.eventb.core.comment="the load address" org.eventb.core.label="grd9" org.eventb.core.predicate="a = address(l)"/>
<org.eventb.core.guard name="_lDY1krs8EeSbduHSoMvCew" org.eventb.core.comment="m has observed a store for this address" org.eventb.core.label="grd10" org.eventb.core.predicate="a ∈ dom(lastobservedvalue(m))"/>
<org.eventb.core.action name="_8IkMZLD_EeSDLL1FFCt7mQ" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_wvi6sLs8EeSbduHSoMvCew" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_D-CwENFbEeSEfrkbRWF-Qw" org.eventb.core.assignment="registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)}" org.eventb.core.comment="load the value of the last observed store for this address" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E(" org.eventb.core.comment="not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStore">
<org.eventb.core.refinesEvent name="_mKQs4NatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStore"/>
<org.eventb.core.parameter name="_6jdLwbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_6jdy0LErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.guard name="_F9cypLBXEeSftfcqDYm3Dw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_DnCwcNatEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_F9dZsbBXEeSftfcqDYm3Dw" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iaHG4LBfEeS2YI9ZOZw9XQ" org.eventb.core.comment="not ahead of a barrier" org.eventb.core.label="grd4" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ⇒ s ∉ ahead(b)"/>
<org.eventb.core.guard name="_r57_cLDwEeSDLL1FFCt7mQ" org.eventb.core.comment="not behind a barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="∀b·b ∈ dom(behind) ⇒ s ∉ behind(b)"/>
<org.eventb.core.action name="_F9dZsrBXEeSftfcqDYm3Dw" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_Nl7GQLBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iaHt8LBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E)" org.eventb.core.comment="constrained by DMB, not all masters have observed the store" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreAheadofDMB">
<org.eventb.core.refinesEvent name="_mKSiENatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreAheadofDMB"/>
<org.eventb.core.parameter name="_6jeZ4bErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_6jeZ4rErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_LvR10bDwEeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_iX3KMLHKEeStFcxm7qdLvQ" org.eventb.core.identifier="o"/>
<org.eventb.core.guard name="_LvR10rDwEeSDLL1FFCt7mQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_DnEloNatEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_LvSc4LDwEeSDLL1FFCt7mQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_LvSc4bDwEeSDLL1FFCt7mQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_LvSc4rDwEeSDLL1FFCt7mQ" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="s ∈ ahead(b)"/>
<org.eventb.core.guard name="_LvSc47DwEeSDLL1FFCt7mQ" org.eventb.core.label="grd6" org.eventb.core.predicate="o ≠ m"/>
<org.eventb.core.guard name="_iX4_YLHKEeStFcxm7qdLvQ" org.eventb.core.comment="there is at least one other master that has not observed this store" org.eventb.core.label="grd7" org.eventb.core.predicate="o ∉ observers(s)"/>
<org.eventb.core.action name="_LvTD8LDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_LvTD8bDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_LvTD8rDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_DnKsQNatEeS8PrcbdDoUAw" org.eventb.core.comment="the master that issued the barrier has issued a LOAD ahead of the barrier that follows this store in observe order" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreLoadAheadofDMB">
<org.eventb.core.refinesEvent name="_mKUXQNatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreLoadAheadofDMB"/>
<org.eventb.core.parameter name="_DnLTUNatEeS8PrcbdDoUAw" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_DnLTUdatEeS8PrcbdDoUAw" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_DnLTUtatEeS8PrcbdDoUAw" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_DnLTU9atEeS8PrcbdDoUAw" org.eventb.core.identifier="l"/>
<org.eventb.core.guard name="_DnLTVNatEeS8PrcbdDoUAw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_DnLTVdatEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_DnL6YNatEeS8PrcbdDoUAw" org.eventb.core.label="grd3" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_DnL6YdatEeS8PrcbdDoUAw" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_DnL6YtatEeS8PrcbdDoUAw" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_DnL6Y9atEeS8PrcbdDoUAw" org.eventb.core.label="grd6" org.eventb.core.predicate="s ∉ ahead(b)"/>
<org.eventb.core.guard name="_DnMhcNatEeS8PrcbdDoUAw" org.eventb.core.label="grd7" org.eventb.core.predicate="l ∈ ahead(b)"/>
<org.eventb.core.guard name="_DnMhcdatEeS8PrcbdDoUAw" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd8" org.eventb.core.predicate="address(l) = address(s)"/>
<org.eventb.core.action name="_DnMhctatEeS8PrcbdDoUAw" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_DnMhc9atEeS8PrcbdDoUAw" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_DnNIgNatEeS8PrcbdDoUAw" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_DnNIgdatEeS8PrcbdDoUAw" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∪ {s}" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E*" org.eventb.core.comment="constrained by DMB, store is observed by the all the masters" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreAheadofDMBComplete">
<org.eventb.core.refinesEvent name="_mKWzgNatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreAheadofDMBComplete"/>
<org.eventb.core.parameter name="_iYCJULHKEeStFcxm7qdLvQ" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_iYCJUbHKEeStFcxm7qdLvQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_iYCJUrHKEeStFcxm7qdLvQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_iYCwYLHKEeStFcxm7qdLvQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_DnGa0NatEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_iYCwYbHKEeStFcxm7qdLvQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iYDXcLHKEeStFcxm7qdLvQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_iYDXcbHKEeStFcxm7qdLvQ" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="s ∈ ahead(b)"/>
<org.eventb.core.guard name="_iYD-gLHKEeStFcxm7qdLvQ" org.eventb.core.comment="m is that last master to observe this store" org.eventb.core.label="grd6" org.eventb.core.predicate="∀o·o ∈ MASTER ∧ o ≠ m ⇒ o ∈ observers(s)"/>
<org.eventb.core.action name="_iYFMoLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_iYFzsLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iYGawLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_iYHB0LHKEeStFcxm7qdLvQ" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∖ {s}" org.eventb.core.comment="remove store from ahead set" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E+" org.eventb.core.comment="constrained by DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreBehindDMB">
<org.eventb.core.refinesEvent name="_mKYosNatEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreBehindDMB"/>
<org.eventb.core.parameter name="_iYIP8bHKEeStFcxm7qdLvQ" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_iYI3ALHKEeStFcxm7qdLvQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_iYI3AbHKEeStFcxm7qdLvQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_iYI3ArHKEeStFcxm7qdLvQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_DnIQANatEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_iYJeELHKEeStFcxm7qdLvQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iYJeEbHKEeStFcxm7qdLvQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_iYKFILHKEeStFcxm7qdLvQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(behind)"/>
<org.eventb.core.guard name="_iYKFIbHKEeStFcxm7qdLvQ" org.eventb.core.comment="all stores ahead of the barrier have been observed" org.eventb.core.label="grd6" org.eventb.core.predicate="ahead(b) = ∅"/>
<org.eventb.core.guard name="_iYKsMLHKEeStFcxm7qdLvQ" org.eventb.core.comment="s is behind the barrier" org.eventb.core.label="grd7" org.eventb.core.predicate="s ∈ behind(b)"/>
<org.eventb.core.action name="_iYLTQbHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_iYL6ULHKEeStFcxm7qdLvQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iYL6UbHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E," org.eventb.core.comment="a master issues a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="issueDMB">
<org.eventb.core.refinesEvent name="_mKad4NatEeS8PrcbdDoUAw" org.eventb.core.target="issueDMB"/>
<org.eventb.core.parameter name="_jj4lYLDuEeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_6jg2ILErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.guard name="_SaZU4rDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd1" org.eventb.core.predicate="b ∈ DMB"/>
<org.eventb.core.guard name="_jj5McLDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="m ∈ MASTER"/>
<org.eventb.core.guard name="_10GNYLDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(b)"/>
<org.eventb.core.guard name="_KxGYccyeEeS35eQk3gU39A" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∉ issuedbarrier"/>
<org.eventb.core.action name="_SaZ78LDuEeSDLL1FFCt7mQ" org.eventb.core.assignment="ahead ≔ ahead  {b ↦ ({t∣t ∈ issued ∧ m = issuer(t) ∧ m ∉ observers(t)} ∪&#10;                                   {s∣s ∈ dom(observers) ∧ m ∈ observers(s) ∧ (∃o·o ∉ observers(s))})}" org.eventb.core.comment="all memory accesses issued by the master but not observed, together with all the STOREs observed by the master but not observed by all other observers" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_OmtZsNOREeSWGfl1zVgqXQ" org.eventb.core.assignment="issuedbarrier ≔ issuedbarrier ∪ {b}" org.eventb.core.label="act2"/>
</org.eventb.core.event>
</org.eventb.core.machineFile>
