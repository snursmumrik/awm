<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.comment="Constrain the model to execute the PROGRAM specified in context AC6" org.eventb.core.configuration="org.eventb.core.fwd" org.eventb.texttools.text_lastmodified="1427705790442" org.eventb.texttools.text_representation="machine AM6&#10;&#10;// Constrain the model to execute the PROGRAM specified in context AC6&#10;&#10;refines AM5  sees AC6&#10;&#10;variables issued observed lastobservedvalue observers ahead behind issuedbarrier registerfile&#10;&#10;invariants&#10;  @inv1 {I21, I23, I31, I33} ⊆ observed ∧ (registerfile(M2))(R1) = V1 ∧ (registerfile(M3))(R1) = V1 ⇒ ¬((registerfile(M2))(R2) = V0 ∧ (registerfile(M3))(R2) = V0)&#10;&#10;events&#10;  event INITIALISATION&#10;    then&#10;      @act1 issued ≔ ∅&#10;      @act2 observed ≔ ∅&#10;      @act3 lastobservedvalue ≔ MASTER × {ADDR × {V0}} // initialise each master's view of memory to the default value V0&#10;      @act4 observers ≔ ∅&#10;      @act5 ahead ≔ ∅&#10;      @act6 behind ≔ DMB × {∅}&#10;      @act7 issuedbarrier ≔ ∅&#10;      @act8 registerfile ≔ MASTER × { REG × {V0} } // initialise the registerfiles to the default value V0&#10;  end&#10;&#10;  event IssueLoad // out of order and the observation of the load is not constrained by a DMB and the issue is not constrained by a DMB&#10;  refines IssueLoad&#10;    any l&#10;    where&#10;      @grd1 l ∉ issued // not already issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅ // if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;      @grd4 ∀b·b ∈ DMB ∧ b ∈ ran(PROGRAM(issuer(l))) ⇒ b ∈ issuedbarrier  // there are no barriers behind the LOAD&#10;    then&#10;      @act1 issued ≔ issued ∪ {l} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {l ↦ ∅}  // establish the set, initially empty, that will hold the observers of the load&#10;  end&#10;&#10;  event IssueLoadAheadofDMB // out of order and the observation of the load is not constrained by a DMB but the issue is constrained by a DMB&#10;  refines IssueLoad&#10;    any l b p n i&#10;    where&#10;      @grd1 l ∉ issued // not already issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅ // if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;      @grd4 b ∈ DMB&#10;      @grd5 b ∉ issuedbarrier&#10;      @grd6 p = PROGRAM(issuer(l))&#10;      @grd7 n ∈ dom(p)&#10;      @grd8 p(n) = b // barrier has position n in program order&#10;      @grd9 ∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ DMB ∧ p(i) ∉ issuedbarrier ⇒ n &lt; i // all other unissued barriers have a higher position in program order&#10;      @grd10 i &lt; n&#10;      @grd11 i ∈ dom(p)&#10;      @grd12 p(i) = l  // LOAD is before the barrier in program order&#10;    then&#10;      @act1 issued ≔ issued ∪ {l} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {l ↦ ∅}  // establish the set, initially empty, that will hold the observers of the load&#10;  end&#10;&#10;  event IssueLoadBehindDMB // out of order and the observation of the load is constrained by a DMB&#10;  refines IssueLoadBehindDMB&#10;    any l b&#10;    where&#10;      @grd1 b ∈ DMB&#10;      @grd2 l ∉ issued // not already issued&#10;      @grd3 l ∈ LOAD&#10;      @grd4 issuer(b) = issuer(l) // the issuer of the load has issued a barrier&#10;      @grd5 b ∈ dom(ahead) // and there are stores ahead of the barrier which have&#10;      @grd6 ahead(b) ≠ ∅ // not been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {l} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {l ↦ ∅}  // establish the set, initially empty, that will hold the observers of the load&#10;      @act3 behind(b) ≔ behind(b) ∪ {l} // load is added to the set of memory accesses behind the barrier&#10;  end&#10;&#10;  event IssueStore // out of order and the observation of the store is not constrained by a DMB and the issue is not constrained by a DMB&#10;  refines IssueStore&#10;    any s&#10;    where&#10;      @grd1 s ∉ issued // not already issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅ // if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;      @grd4 ∀b·b ∈ DMB ∧ b ∈ ran(PROGRAM(issuer(s))) ⇒ b ∈ issuedbarrier // there are no barriers behind the STORE&#10;    then&#10;      @act1 issued ≔ issued ∪ {s} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {s ↦ ∅} // establish the set, initially empty, that will hold the observers of the store&#10;  end&#10;&#10;  event IssueStoreAheadofDMB // out of order and the observation of the store is not constrained by a DMB but the issue is constrained by a DMB&#10;  refines IssueStore&#10;    any s b p n i&#10;    where&#10;      @grd1 s ∉ issued // not already issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅ // if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;      @grd4 b ∈ DMB&#10;      @grd5 b ∉ issuedbarrier&#10;      @grd6 p = PROGRAM(issuer(s))&#10;      @grd7 n ∈ dom(p)&#10;      @grd8 p(n) = b // barrier has position n in program order&#10;      @grd9 ∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ DMB ∧ p(i) ∉ issuedbarrier ⇒ n &lt; i // all other unissued barriers have a higher position in program order&#10;      @grd10 i &lt; n&#10;      @grd11 i ∈ dom(p)&#10;      @grd12 p(i) = s //STORE is before the barrier in program order&#10;    then&#10;      @act1 issued ≔ issued ∪ {s} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {s ↦ ∅} // establish the set, initially empty, that will hold the observers of the store&#10;  end&#10;&#10;  event IssueStoreBehindDMB // out of order and the observation of the store is constrained by a DMB&#10;  refines IssueStoreBehindDMB&#10;    any s b&#10;    where&#10;      @grd1 s ∉ issued // not already issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 issuer(b) = issuer(s) // the issuer of the store has issued a barrier&#10;      @grd4 b ∈ dom(ahead) // and there are stores ahead of the barrier which have&#10;      @grd5 ahead(b) ≠ ∅ // not been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {s} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {s ↦ ∅} // establish the set, initially empty, that will hold the observers of the store&#10;      @act3 behind(b) ≔ behind(b) ∪ {s} // store is added to the set of memory accesses behind the barrier&#10;  end&#10;&#10;  event ObserveLoad // not constrained by a DMB&#10;  refines ObserveLoad&#10;    any l m a&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 ∀b·b ∈ dom(ahead) ⇒ l ∉ ahead(b)  // not ahead of a barrier&#10;      @grd6 ∀b·b ∈ dom(behind) ⇒ l ∉ behind(b) // load is not behind any barrier&#10;      @grd7 a = address(l) // the load address&#10;      @grd8 a ∈ dom(lastobservedvalue(m)) // m has observed a store for this address&#10;      @grd9 l ∈ dom(addressdependency) ⇒ addressdependency(l) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;      @act3 registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)} // load the value of the last observed store for this address&#10;  end&#10;&#10;  event ObserveLoadAheadofDMB // constrained by a DMB - the master issuing the DMB observes loads it has issued before the DMB&#10;  refines ObserveLoadAheadofDMB&#10;    any l m b a&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 l ∈ ahead(b) //  is ahead of the barrier&#10;      @grd7 a = address(l) // the load address&#10;      @grd8 a ∈ dom(lastobservedvalue(m)) // m has observed a store for this address&#10;      @grd9 l ∈ dom(addressdependency) ⇒ addressdependency(l) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;      @act3 ahead(b) ≔ ahead(b) ∖ {l}  // remove load from ahead set&#10;      @act4 registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)} // load the value of the last observed store for this address&#10;  end&#10;&#10;  event ObserveLoadBehindDMB // constrained by a DMB: cannot be observed until all stores ahead of the barrier have been observed&#10;  refines ObserveLoadBehindDMB&#10;    any l b m a&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 b ∈ dom(behind)&#10;      @grd7 l ∈ behind(b) // load is behind a barrier&#10;      @grd8 ahead(b) = ∅ // all stores ahead of the barrier have been observed&#10;      @grd9 a = address(l) // the load address&#10;      @grd10 a ∈ dom(lastobservedvalue(m)) // m has observed a store for this address&#10;      @grd11 l ∈ dom(addressdependency) ⇒ addressdependency(l) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;      @act3 registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)} // load the value of the last observed store for this address&#10;  end&#10;&#10;  event ObserveStore // not constrained by a DMB&#10;  refines ObserveStore&#10;    any s m&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 ∀b·b ∈ dom(ahead) ⇒ s ∉ ahead(b) // not ahead of a barrier&#10;      @grd5 ∀b·b ∈ dom(behind) ⇒ s ∉ behind(b) // not behind a barrier&#10;      @grd6 ∀b·b ∈ issuedbarrier ∧ b ∈ dom(ahead) ∧ ahead(b) ≠ ∅ ∧ (∃l·l ∈ ahead(b) ∧ address(l) = address(s)) ⇒ m ≠ issuer(b)&#10;      @grd7 issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m}&#10;  end&#10;&#10;  event ObserveStoreAheadofDMB // constrained by DMB, not all masters have observed the store&#10;  refines ObserveStoreAheadofDMB&#10;    any s m b o&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 s ∈ ahead(b) //∨  (l ∈ ahead(b) ∧ address(l) = address(s)) // s is ahead of the barrier&#10;      @grd6 o ≠ m&#10;      @grd7 o ∉ observers(s) // there is at least one other master that has not observed this store&#10;      @grd8 issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;  end&#10;&#10;  event ObserveStoreLoadAheadofDMB // constrained by DMB, the master that issued the barrier has issued a LOAD ahead of the barrier that follows this store in observe order&#10;  refines ObserveStoreLoadAheadofDMB&#10;    any s m b l&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 l ∈ LOAD&#10;      @grd4 l ∈ issued&#10;      @grd5 b ∈ issuedbarrier&#10;      @grd6 m ∉ observers(s) // the master has not already observed this store&#10;      @grd7 b ∈ dom(ahead)&#10;      @grd8 issuer(b) = m&#10;      @grd9 s ∉ ahead(b)&#10;      @grd10 l ∈ ahead(b)&#10;      @grd11 address(l) = address(s)  // s is ahead of the barrier&#10;      @grd12 issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;      @act4 ahead(b) ≔ ahead(b) ∪ {s}&#10;  end&#10;&#10;  event ObserveStoreAheadofDMBComplete // constrained by DMB, store is observed by the all the masters&#10;  refines ObserveStoreAheadofDMBComplete&#10;    any s m b&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 s ∈ ahead(b) // s is ahead of the barrier&#10;      @grd6 ∀o·o ∈ MASTER ∧ o ≠ m ⇒ o ∈ observers(s) // m is that last master to observe this store&#10;      @grd7 issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;      @act4 ahead(b) ≔ ahead(b) ∖ {s} // remove store from ahead set&#10;  end&#10;&#10;  event ObserveStoreBehindDMB // constrained by DMB&#10;  refines ObserveStoreBehindDMB&#10;    any s m b&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 b ∈ dom(behind)&#10;      @grd6 ahead(b) = ∅ // all stores ahead of the barrier have been observed&#10;      @grd7 s ∈ behind(b) // s is behind the barrier&#10;      @grd8 issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed // must be observed in program order&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;  end&#10;&#10;  event issueDMB // a master issues a DMB&#10;  refines issueDMB&#10;    any b m p n&#10;    where&#10;      @grd1 b ∈ DMB&#10;      @grd2 m ∈ MASTER&#10;      @grd3 m = issuer(b)&#10;      @grd4 b ∉ issuedbarrier&#10;      @grd5 p = PROGRAM(m)&#10;      @grd6 n ∈ dom(p)&#10;      @grd7 p(n) = b&#10;      @grd8 ∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ DMB ∧ p(i) ∉ issuedbarrier ⇒ n &lt; i // all other unissued barriers have a higher position in program order&#10;      @grd9 ∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ MEMACCESS ∧ p(i) ∉ issued ⇒ n &lt; i // there are no unissued memory accessses before the barrier in program order&#10;    then&#10;      @act1 ahead ≔ ahead  {b ↦ ({t∣t ∈ issued ∧ m = issuer(t) ∧ m ∉ observers(t)} ∪&#10;                                   {s∣s ∈ dom(observers) ∧ m ∈ observers(s) ∧ (∃o·o ∉ observers(s))})} // all memory accesses issued by the master but not observed, together with all the STOREs observed by the master but not observed by all other observers&#10;      @act2 issuedbarrier ≔ issuedbarrier ∪ {b}&#10;  end&#10;end&#10;" version="5">
<org.eventb.core.refinesMachine name="_SR63MNayEeS8PrcbdDoUAw" org.eventb.core.target="AM5"/>
<org.eventb.core.seesContext name="_SR63MdayEeS8PrcbdDoUAw" org.eventb.core.target="AC6"/>
<org.eventb.core.variable name="(" org.eventb.core.identifier="issued"/>
<org.eventb.core.variable name="_w4qjgLBREeSftfcqDYm3Dx" org.eventb.core.identifier="observed"/>
<org.eventb.core.variable name="_noQRoLBdEeS2YI9ZOZw9XQ" org.eventb.core.identifier="lastobservedvalue"/>
<org.eventb.core.variable name="_fUdnQNFeEeSEfrkbRWF-Qw" org.eventb.core.identifier="observers"/>
<org.eventb.core.variable name="_SaT1UrDuEeSDLL1FFCt7mQ" org.eventb.core.identifier="ahead"/>
<org.eventb.core.variable name="_7OyMELD8EeSDLL1FFCt7mQ" org.eventb.core.identifier="behind"/>
<org.eventb.core.variable name="_aGhDQsyeEeS35eQk3gU39A" org.eventb.core.identifier="issuedbarrier"/>
<org.eventb.core.variable name="_dBTdMLs2EeSbduHSoMvCew" org.eventb.core.identifier="registerfile"/>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3Dy" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
<org.eventb.core.action name="'" org.eventb.core.assignment="issued ≔ ∅" org.eventb.core.label="act1"/>
<org.eventb.core.action name="(" org.eventb.core.assignment="observed ≔ ∅" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_noQ4sLBdEeS2YI9ZOZw9XQ" org.eventb.core.assignment="lastobservedvalue ≔ MASTER × {ADDR × {V0}}" org.eventb.core.comment="initialise each master's view of memory to the default value V0" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_lW8g4LBeEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers ≔ ∅" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_SaVDcLDuEeSDLL1FFCt7mQ" org.eventb.core.assignment="ahead ≔ ∅" org.eventb.core.label="act5"/>
<org.eventb.core.action name="_7OyzILD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="behind ≔ DMB × {∅}" org.eventb.core.label="act6"/>
<org.eventb.core.action name="_n2xx8Ls2EeSbduHSoMvCew" org.eventb.core.assignment="issuedbarrier ≔ ∅" org.eventb.core.label="act7"/>
<org.eventb.core.action name="_aGiRYMyeEeS35eQk3gU39A" org.eventb.core.assignment="registerfile ≔ MASTER × { REG × {V0} }" org.eventb.core.comment="initialise the registerfiles to the default value V0" org.eventb.core.label="act8"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3Dz" org.eventb.core.comment="out of order and the observation of the load is not constrained by a DMB and the issue is not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueLoad">
<org.eventb.core.refinesEvent name="_SR8sYNayEeS8PrcbdDoUAw" org.eventb.core.target="IssueLoad"/>
<org.eventb.core.parameter name="_6jYTQbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.guard name="_5G8aQ7BWEeSftfcqDYm3Dw" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∉ issued"/>
<org.eventb.core.guard name="_5G9BULBWEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_B5KugLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅"/>
<org.eventb.core.guard name="_WypyoM1KEeS35eQk3gU39A" org.eventb.core.comment="there are no barriers behind the LOAD" org.eventb.core.label="grd4" org.eventb.core.predicate="∀b·b ∈ DMB ∧ b ∈ ran(PROGRAM(issuer(l))) ⇒ b ∈ issuedbarrier"/>
<org.eventb.core.action name="_5G9BUbBWEeSftfcqDYm3Dw" org.eventb.core.assignment="issued ≔ issued ∪ {l}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_JWuvMNFfEeSEfrkbRWF-Qw" org.eventb.core.assignment="observers ≔ observers  {l ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the load" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_UNKzkM1JEeS35eQk3gU39A" org.eventb.core.comment="out of order and the observation of the load is not constrained by a DMB but the issue is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueLoadAheadofDMB">
<org.eventb.core.refinesEvent name="_SR9TcNayEeS8PrcbdDoUAw" org.eventb.core.target="IssueLoad"/>
<org.eventb.core.parameter name="_UNKzks1JEeS35eQk3gU39A" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_59TeUc1REeS35eQk3gU39A" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_59TeUs1REeS35eQk3gU39A" org.eventb.core.identifier="p"/>
<org.eventb.core.parameter name="_59TeU81REeS35eQk3gU39A" org.eventb.core.identifier="n"/>
<org.eventb.core.parameter name="_59TeVM1REeS35eQk3gU39A" org.eventb.core.identifier="i"/>
<org.eventb.core.guard name="_UNKzk81JEeS35eQk3gU39A" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∉ issued"/>
<org.eventb.core.guard name="_UNKzlM1JEeS35eQk3gU39A" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_UNKzlc1JEeS35eQk3gU39A" org.eventb.core.comment="if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅"/>
<org.eventb.core.guard name="_59UFYM1REeS35eQk3gU39A" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ DMB"/>
<org.eventb.core.guard name="_59UFY81REeS35eQk3gU39A" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∉ issuedbarrier"/>
<org.eventb.core.guard name="__C0UsM1TEeS35eQk3gU39A" org.eventb.core.label="grd6" org.eventb.core.predicate="p = PROGRAM(issuer(l))"/>
<org.eventb.core.guard name="_59UFZM1REeS35eQk3gU39A" org.eventb.core.label="grd7" org.eventb.core.predicate="n ∈ dom(p)"/>
<org.eventb.core.guard name="_59UFZc1REeS35eQk3gU39A" org.eventb.core.comment="barrier has position n in program order" org.eventb.core.label="grd8" org.eventb.core.predicate="p(n) = b"/>
<org.eventb.core.guard name="_59UscM1REeS35eQk3gU39A" org.eventb.core.comment="all other unissued barriers have a higher position in program order" org.eventb.core.label="grd9" org.eventb.core.predicate="∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ DMB ∧ p(i) ∉ issuedbarrier ⇒ n &lt; i"/>
<org.eventb.core.guard name="_3y7wkNapEeS8PrcbdDoUAw" org.eventb.core.label="grd10" org.eventb.core.predicate="i &lt; n"/>
<org.eventb.core.guard name="_3y7wkdapEeS8PrcbdDoUAw" org.eventb.core.label="grd11" org.eventb.core.predicate="i ∈ dom(p)"/>
<org.eventb.core.guard name="_3y8XoNapEeS8PrcbdDoUAw" org.eventb.core.comment="LOAD is before the barrier in program order" org.eventb.core.label="grd12" org.eventb.core.predicate="p(i) = l"/>
<org.eventb.core.action name="_UNLaoM1JEeS35eQk3gU39A" org.eventb.core.assignment="issued ≔ issued ∪ {l}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_JWwkYNFfEeSEfrkbRWF-Qw" org.eventb.core.assignment="observers ≔ observers  {l ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the load" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D{" org.eventb.core.comment="out of order and the observation of the load is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueLoadBehindDMB">
<org.eventb.core.refinesEvent name="_SR_IoNayEeS8PrcbdDoUAw" org.eventb.core.target="IssueLoadBehindDMB"/>
<org.eventb.core.parameter name="_6jY6UbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_B5UfgrD_EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_B5Ufg7D_EeSDLL1FFCt7mQ" org.eventb.core.label="grd1" org.eventb.core.predicate="b ∈ DMB"/>
<org.eventb.core.guard name="_B5UfhLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="not already issued" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∉ issued"/>
<org.eventb.core.guard name="_B5VGkLD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd3" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_B5VGkbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the issuer of the load has issued a barrier" org.eventb.core.label="grd4" org.eventb.core.predicate="issuer(b) = issuer(l)"/>
<org.eventb.core.guard name="_B5VGkrD_EeSDLL1FFCt7mQ" org.eventb.core.comment="and there are stores ahead of the barrier which have" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_3y_a8NapEeS8PrcbdDoUAw" org.eventb.core.comment="not been observed" org.eventb.core.label="grd6" org.eventb.core.predicate="ahead(b) ≠ ∅"/>
<org.eventb.core.action name="_B5VGk7D_EeSDLL1FFCt7mQ" org.eventb.core.assignment="issued ≔ issued ∪ {l}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_B5VGlLD_EeSDLL1FFCt7mQ" org.eventb.core.assignment="observers ≔ observers  {l ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_JWxLcNFfEeSEfrkbRWF-Qw" org.eventb.core.assignment="behind(b) ≔ behind(b) ∪ {l}" org.eventb.core.comment="load is added to the set of memory accesses behind the barrier" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D|" org.eventb.core.comment="out of order and the observation of the store is not constrained by a DMB and the issue is not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueStore">
<org.eventb.core.refinesEvent name="_SSAWwNayEeS8PrcbdDoUAw" org.eventb.core.target="IssueStore"/>
<org.eventb.core.parameter name="_6jaIcbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.guard name="_5G9oYrBWEeSftfcqDYm3Dw" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∉ issued"/>
<org.eventb.core.guard name="_5G9oY7BWEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_jNTeIbD-EeSDLL1FFCt7mQ" org.eventb.core.comment="if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅"/>
<org.eventb.core.guard name="_FoE7cNaqEeS8PrcbdDoUAw" org.eventb.core.comment="there are no barriers behind the STORE" org.eventb.core.label="grd4" org.eventb.core.predicate="∀b·b ∈ DMB ∧ b ∈ ran(PROGRAM(issuer(s))) ⇒ b ∈ issuedbarrier"/>
<org.eventb.core.action name="_5G9oZLBWEeSftfcqDYm3Dw" org.eventb.core.assignment="issued ≔ issued ∪ {s}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_HHecIbBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers ≔ observers  {s ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the store" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_0XUYIM1PEeS35eQk3gU39A" org.eventb.core.comment="out of order and the observation of the store is not constrained by a DMB but the issue is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueStoreAheadofDMB">
<org.eventb.core.refinesEvent name="_SSA90NayEeS8PrcbdDoUAw" org.eventb.core.target="IssueStore"/>
<org.eventb.core.parameter name="_0XUYIs1PEeS35eQk3gU39A" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_xBnOUc1UEeS35eQk3gU39A" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_xBnOUs1UEeS35eQk3gU39A" org.eventb.core.identifier="p"/>
<org.eventb.core.parameter name="_xBnOU81UEeS35eQk3gU39A" org.eventb.core.identifier="n"/>
<org.eventb.core.parameter name="_xBnOVM1UEeS35eQk3gU39A" org.eventb.core.identifier="i"/>
<org.eventb.core.guard name="_0XUYI81PEeS35eQk3gU39A" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∉ issued"/>
<org.eventb.core.guard name="_0XU_MM1PEeS35eQk3gU39A" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_0XU_Mc1PEeS35eQk3gU39A" org.eventb.core.comment="if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅"/>
<org.eventb.core.guard name="_xBn1YM1UEeS35eQk3gU39A" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ DMB"/>
<org.eventb.core.guard name="_xBn1Yc1UEeS35eQk3gU39A" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∉ issuedbarrier"/>
<org.eventb.core.guard name="_xBn1Ys1UEeS35eQk3gU39A" org.eventb.core.label="grd6" org.eventb.core.predicate="p = PROGRAM(issuer(s))"/>
<org.eventb.core.guard name="_xBoccM1UEeS35eQk3gU39A" org.eventb.core.label="grd7" org.eventb.core.predicate="n ∈ dom(p)"/>
<org.eventb.core.guard name="_xBoccc1UEeS35eQk3gU39A" org.eventb.core.comment="barrier has position n in program order" org.eventb.core.label="grd8" org.eventb.core.predicate="p(n) = b"/>
<org.eventb.core.guard name="_xBoccs1UEeS35eQk3gU39A" org.eventb.core.comment="all other unissued barriers have a higher position in program order" org.eventb.core.label="grd9" org.eventb.core.predicate="∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ DMB ∧ p(i) ∉ issuedbarrier ⇒ n &lt; i"/>
<org.eventb.core.guard name="_FoH-wNaqEeS8PrcbdDoUAw" org.eventb.core.label="grd10" org.eventb.core.predicate="i &lt; n"/>
<org.eventb.core.guard name="_FoIl0NaqEeS8PrcbdDoUAw" org.eventb.core.label="grd11" org.eventb.core.predicate="i ∈ dom(p)"/>
<org.eventb.core.guard name="_FoIl0daqEeS8PrcbdDoUAw" org.eventb.core.comment="STORE is before the barrier in program order" org.eventb.core.label="grd12" org.eventb.core.predicate="p(i) = s"/>
<org.eventb.core.action name="_0XU_Ms1PEeS35eQk3gU39A" org.eventb.core.assignment="issued ≔ issued ∪ {s}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_0XU_M81PEeS35eQk3gU39A" org.eventb.core.assignment="observers ≔ observers  {s ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the store" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D}" org.eventb.core.comment="out of order and the observation of the store is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueStoreBehindDMB">
<org.eventb.core.refinesEvent name="_SSCL8NayEeS8PrcbdDoUAw" org.eventb.core.target="IssueStoreBehindDMB"/>
<org.eventb.core.parameter name="_6javgbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_fyTBwrD8EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_fyTBw7D8EeSDLL1FFCt7mQ" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∉ issued"/>
<org.eventb.core.guard name="_fyTBxLD8EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_fyTo0LD8EeSDLL1FFCt7mQ" org.eventb.core.comment="the issuer of the store has issued a barrier" org.eventb.core.label="grd3" org.eventb.core.predicate="issuer(b) = issuer(s)"/>
<org.eventb.core.guard name="_fyTo0bD8EeSDLL1FFCt7mQ" org.eventb.core.comment="and there are stores ahead of the barrier which have" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_fyTo0rD8EeSDLL1FFCt7mQ" org.eventb.core.comment="not been observed" org.eventb.core.label="grd5" org.eventb.core.predicate="ahead(b) ≠ ∅"/>
<org.eventb.core.action name="_fyTo07D8EeSDLL1FFCt7mQ" org.eventb.core.assignment="issued ≔ issued ∪ {s}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_fyUP4LD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="observers ≔ observers  {s ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the store" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_7O2dgLD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="behind(b) ≔ behind(b) ∪ {s}" org.eventb.core.comment="store is added to the set of memory accesses behind the barrier" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D~" org.eventb.core.comment="not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoad">
<org.eventb.core.refinesEvent name="_SSCzANayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoad"/>
<org.eventb.core.parameter name="_6jb9obErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_hRwB4bs6EeSbduHSoMvCew" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_7rFQobs7EeSbduHSoMvCew" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_F9cLkbBXEeSftfcqDYm3Dw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_F9cLkrBXEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_8IdesbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="__Xjk8LHQEeSNlasBfv989A" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_hRwo8Ls6EeSbduHSoMvCew" org.eventb.core.comment="not ahead of a barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ⇒ l ∉ ahead(b)"/>
<org.eventb.core.guard name="_7rGewLs7EeSbduHSoMvCew" org.eventb.core.comment="load is not behind any barrier" org.eventb.core.label="grd6" org.eventb.core.predicate="∀b·b ∈ dom(behind) ⇒ l ∉ behind(b)"/>
<org.eventb.core.guard name="_7rGewbs7EeSbduHSoMvCew" org.eventb.core.comment="the load address" org.eventb.core.label="grd7" org.eventb.core.predicate="a = address(l)"/>
<org.eventb.core.guard name="_TlookNIiEeSEfrkbRWF-Qw" org.eventb.core.comment="m has observed a store for this address" org.eventb.core.label="grd8" org.eventb.core.predicate="a ∈ dom(lastobservedvalue(m))"/>
<org.eventb.core.guard name="_JiFMwNOSEeSWGfl1zVgqXQ" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd9" org.eventb.core.predicate="l ∈ dom(addressdependency) ⇒ addressdependency(l) ∈ observed"/>
<org.eventb.core.action name="_F9cyoLBXEeSftfcqDYm3Dw" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_hRxQALs6EeSbduHSoMvCew" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_JW2D8NFfEeSEfrkbRWF-Qw" org.eventb.core.assignment="registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)}" org.eventb.core.comment="load the value of the last observed store for this address" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_xWJXwNOSEeSWGfl1zVgqXQ" org.eventb.core.comment="constrained by a DMB - the master issuing the DMB observes loads it has issued before the DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoadAheadofDMB">
<org.eventb.core.refinesEvent name="_SSEBINayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoadAheadofDMB"/>
<org.eventb.core.parameter name="_xWJ-0NOSEeSWGfl1zVgqXQ" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_xWJ-0dOSEeSWGfl1zVgqXQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_xWJ-0tOSEeSWGfl1zVgqXQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_xWJ-09OSEeSWGfl1zVgqXQ" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_xWJ-1NOSEeSWGfl1zVgqXQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_xWJ-1dOSEeSWGfl1zVgqXQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_xWJ-1tOSEeSWGfl1zVgqXQ" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="_xWKl4NOSEeSWGfl1zVgqXQ" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_xWKl4dOSEeSWGfl1zVgqXQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_xWKl4tOSEeSWGfl1zVgqXQ" org.eventb.core.comment="is ahead of the barrier" org.eventb.core.label="grd6" org.eventb.core.predicate="l ∈ ahead(b)"/>
<org.eventb.core.guard name="_xWKl49OSEeSWGfl1zVgqXQ" org.eventb.core.comment="the load address" org.eventb.core.label="grd7" org.eventb.core.predicate="a = address(l)"/>
<org.eventb.core.guard name="_xWKl5NOSEeSWGfl1zVgqXQ" org.eventb.core.comment="m has observed a store for this address" org.eventb.core.label="grd8" org.eventb.core.predicate="a ∈ dom(lastobservedvalue(m))"/>
<org.eventb.core.guard name="_xWKl5dOSEeSWGfl1zVgqXQ" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd9" org.eventb.core.predicate="l ∈ dom(addressdependency) ⇒ addressdependency(l) ∈ observed"/>
<org.eventb.core.action name="_xWLM8NOSEeSWGfl1zVgqXQ" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_xWLM8dOSEeSWGfl1zVgqXQ" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_xWLM8tOSEeSWGfl1zVgqXQ" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∖ {l}" org.eventb.core.comment="remove load from ahead set" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_xWLM89OSEeSWGfl1zVgqXQ" org.eventb.core.assignment="registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)}" org.eventb.core.comment="load the value of the last observed store for this address" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E'" org.eventb.core.comment="constrained by a DMB: cannot be observed until all stores ahead of the barrier have been observed" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoadBehindDMB">
<org.eventb.core.refinesEvent name="_SSFPQNayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoadBehindDMB"/>
<org.eventb.core.parameter name="_6jcksbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_8IjlUrD_EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_lDXncLs8EeSbduHSoMvCew" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_lDXncbs8EeSbduHSoMvCew" org.eventb.core.identifier="a"/>
<org.eventb.core.guard name="_8IjlU7D_EeSDLL1FFCt7mQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_8IjlVLD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_8IkMYLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="_8IkMYbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_8IkMYrD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_8IkMY7D_EeSDLL1FFCt7mQ" org.eventb.core.label="grd6" org.eventb.core.predicate="b ∈ dom(behind)"/>
<org.eventb.core.guard name="_2bFLcLHLEeStFcxm7qdLvQ" org.eventb.core.comment="load is behind a barrier" org.eventb.core.label="grd7" org.eventb.core.predicate="l ∈ behind(b)"/>
<org.eventb.core.guard name="_lDY1kLs8EeSbduHSoMvCew" org.eventb.core.comment="all stores ahead of the barrier have been observed" org.eventb.core.label="grd8" org.eventb.core.predicate="ahead(b) = ∅"/>
<org.eventb.core.guard name="_lDY1kbs8EeSbduHSoMvCew" org.eventb.core.comment="the load address" org.eventb.core.label="grd9" org.eventb.core.predicate="a = address(l)"/>
<org.eventb.core.guard name="_lDY1krs8EeSbduHSoMvCew" org.eventb.core.comment="m has observed a store for this address" org.eventb.core.label="grd10" org.eventb.core.predicate="a ∈ dom(lastobservedvalue(m))"/>
<org.eventb.core.guard name="_40KogNOSEeSWGfl1zVgqXQ" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd11" org.eventb.core.predicate="l ∈ dom(addressdependency) ⇒ addressdependency(l) ∈ observed"/>
<org.eventb.core.action name="_8IkMZLD_EeSDLL1FFCt7mQ" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_wvi6sLs8EeSbduHSoMvCew" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_JW3SENFfEeSEfrkbRWF-Qw" org.eventb.core.assignment="registerfile(m) ≔ registerfile(m)  {register(l) ↦ (lastobservedvalue(m))(a)}" org.eventb.core.comment="load the value of the last observed store for this address" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E(" org.eventb.core.comment="not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStore">
<org.eventb.core.refinesEvent name="_SSGdYNayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStore"/>
<org.eventb.core.parameter name="_6jdLwbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_6jdy0LErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.guard name="_F9cypLBXEeSftfcqDYm3Dw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_quGy4NaqEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_F9dZsbBXEeSftfcqDYm3Dw" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iaHG4LBfEeS2YI9ZOZw9XQ" org.eventb.core.comment="not ahead of a barrier" org.eventb.core.label="grd4" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ⇒ s ∉ ahead(b)"/>
<org.eventb.core.guard name="_r57_cLDwEeSDLL1FFCt7mQ" org.eventb.core.comment="not behind a barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="∀b·b ∈ dom(behind) ⇒ s ∉ behind(b)"/>
<org.eventb.core.guard name="_A7_xELD-EeSDLL1FFCt7mQ" org.eventb.core.label="grd6" org.eventb.core.predicate="∀b·b ∈ issuedbarrier ∧ b ∈ dom(ahead) ∧ ahead(b) ≠ ∅ ∧ (∃l·l ∈ ahead(b) ∧ address(l) = address(s)) ⇒ m ≠ issuer(b)"/>
<org.eventb.core.guard name="_SSHEcNayEeS8PrcbdDoUAw" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd7" org.eventb.core.predicate="issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed"/>
<org.eventb.core.action name="_F9dZsrBXEeSftfcqDYm3Dw" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_Nl7GQLBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iaHt8LBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E)" org.eventb.core.comment="constrained by DMB, not all masters have observed the store" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreAheadofDMB">
<org.eventb.core.refinesEvent name="_SSHrgNayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreAheadofDMB"/>
<org.eventb.core.parameter name="_6jeZ4bErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_6jeZ4rErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_LvR10bDwEeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_iX3KMLHKEeStFcxm7qdLvQ" org.eventb.core.identifier="o"/>
<org.eventb.core.guard name="_LvR10rDwEeSDLL1FFCt7mQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_3ECNwNaqEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_LvSc4LDwEeSDLL1FFCt7mQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_LvSc4bDwEeSDLL1FFCt7mQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_LvSc4rDwEeSDLL1FFCt7mQ" org.eventb.core.comment="∨  (l ∈ ahead(b) ∧ address(l) = address(s)) // s is ahead of the barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="s ∈ ahead(b)"/>
<org.eventb.core.guard name="_LvSc47DwEeSDLL1FFCt7mQ" org.eventb.core.label="grd6" org.eventb.core.predicate="o ≠ m"/>
<org.eventb.core.guard name="_iX4_YLHKEeStFcxm7qdLvQ" org.eventb.core.comment="there is at least one other master that has not observed this store" org.eventb.core.label="grd7" org.eventb.core.predicate="o ∉ observers(s)"/>
<org.eventb.core.guard name="_SSISkNayEeS8PrcbdDoUAw" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd8" org.eventb.core.predicate="issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed"/>
<org.eventb.core.action name="_LvTD8LDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_LvTD8bDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_LvTD8rDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_mI6T8NarEeS8PrcbdDoUAw" org.eventb.core.comment="constrained by DMB, the master that issued the barrier has issued a LOAD ahead of the barrier that follows this store in observe order" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreLoadAheadofDMB">
<org.eventb.core.refinesEvent name="_SSRcgNayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreLoadAheadofDMB"/>
<org.eventb.core.parameter name="_mI67AdarEeS8PrcbdDoUAw" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_mI67AtarEeS8PrcbdDoUAw" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_mI67A9arEeS8PrcbdDoUAw" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_mI7iENarEeS8PrcbdDoUAw" org.eventb.core.identifier="l"/>
<org.eventb.core.guard name="_mI7iEdarEeS8PrcbdDoUAw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_2DIU8NarEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_mI7iEtarEeS8PrcbdDoUAw" org.eventb.core.label="grd3" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_mI8JI9arEeS8PrcbdDoUAw" org.eventb.core.label="grd4" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_mI8wMNarEeS8PrcbdDoUAw" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ issuedbarrier"/>
<org.eventb.core.guard name="_mI8wMtarEeS8PrcbdDoUAw" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd6" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_2DI8ANarEeS8PrcbdDoUAw" org.eventb.core.label="grd7" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_mI8wMdarEeS8PrcbdDoUAw" org.eventb.core.label="grd8" org.eventb.core.predicate="issuer(b) = m"/>
<org.eventb.core.guard name="_mI9XQNarEeS8PrcbdDoUAw" org.eventb.core.label="grd9" org.eventb.core.predicate="s ∉ ahead(b)"/>
<org.eventb.core.guard name="_2DN0gNarEeS8PrcbdDoUAw" org.eventb.core.label="grd10" org.eventb.core.predicate="l ∈ ahead(b)"/>
<org.eventb.core.guard name="_mI9XQdarEeS8PrcbdDoUAw" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd11" org.eventb.core.predicate="address(l) = address(s)"/>
<org.eventb.core.guard name="_SSSqoNayEeS8PrcbdDoUAw" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd12" org.eventb.core.predicate="issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed"/>
<org.eventb.core.action name="_mI9XQtarEeS8PrcbdDoUAw" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_mI9-UNarEeS8PrcbdDoUAw" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_mI9-UdarEeS8PrcbdDoUAw" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_mI9-UtarEeS8PrcbdDoUAw" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∪ {s}" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E*" org.eventb.core.comment="constrained by DMB, store is observed by the all the masters" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreAheadofDMBComplete">
<org.eventb.core.refinesEvent name="_SSTRsNayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreAheadofDMBComplete"/>
<org.eventb.core.parameter name="_iYCJULHKEeStFcxm7qdLvQ" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_iYCJUbHKEeStFcxm7qdLvQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_iYCJUrHKEeStFcxm7qdLvQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_iYCwYLHKEeStFcxm7qdLvQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_2DPpsNarEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_iYCwYbHKEeStFcxm7qdLvQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iYDXcLHKEeStFcxm7qdLvQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_iYDXcbHKEeStFcxm7qdLvQ" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="s ∈ ahead(b)"/>
<org.eventb.core.guard name="_iYD-gLHKEeStFcxm7qdLvQ" org.eventb.core.comment="m is that last master to observe this store" org.eventb.core.label="grd6" org.eventb.core.predicate="∀o·o ∈ MASTER ∧ o ≠ m ⇒ o ∈ observers(s)"/>
<org.eventb.core.guard name="_iYElkLHKEeStFcxm7qdLvQ" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd7" org.eventb.core.predicate="issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed"/>
<org.eventb.core.action name="_iYFMoLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_iYFzsLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iYGawLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_iYHB0LHKEeStFcxm7qdLvQ" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∖ {s}" org.eventb.core.comment="remove store from ahead set" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E+" org.eventb.core.comment="constrained by DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreBehindDMB">
<org.eventb.core.refinesEvent name="_SST4wNayEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStoreBehindDMB"/>
<org.eventb.core.parameter name="_iYIP8bHKEeStFcxm7qdLvQ" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_iYI3ALHKEeStFcxm7qdLvQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_iYI3AbHKEeStFcxm7qdLvQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_iYI3ArHKEeStFcxm7qdLvQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_LIdI4dasEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_iYJeELHKEeStFcxm7qdLvQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iYJeEbHKEeStFcxm7qdLvQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_iYKFILHKEeStFcxm7qdLvQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(behind)"/>
<org.eventb.core.guard name="_iYKFIbHKEeStFcxm7qdLvQ" org.eventb.core.comment="all stores ahead of the barrier have been observed" org.eventb.core.label="grd6" org.eventb.core.predicate="ahead(b) = ∅"/>
<org.eventb.core.guard name="_iYKsMLHKEeStFcxm7qdLvQ" org.eventb.core.comment="s is behind the barrier" org.eventb.core.label="grd7" org.eventb.core.predicate="s ∈ behind(b)"/>
<org.eventb.core.guard name="_iYLTQLHKEeStFcxm7qdLvQ" org.eventb.core.comment="must be observed in program order" org.eventb.core.label="grd8" org.eventb.core.predicate="issuer(s) = m ∧ s ∈ dom(addressdependency) ⇒ addressdependency(s) ∈ observed"/>
<org.eventb.core.action name="_iYLTQbHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_iYL6ULHKEeStFcxm7qdLvQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iYL6UbHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3E," org.eventb.core.comment="a master issues a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="issueDMB">
<org.eventb.core.refinesEvent name="_SSVG4NayEeS8PrcbdDoUAw" org.eventb.core.target="issueDMB"/>
<org.eventb.core.parameter name="_jj4lYLDuEeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_6jg2ILErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_Zy2QYc1OEeS35eQk3gU39A" org.eventb.core.identifier="p"/>
<org.eventb.core.parameter name="_Zy23cM1OEeS35eQk3gU39A" org.eventb.core.identifier="n"/>
<org.eventb.core.guard name="_SaZU4rDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd1" org.eventb.core.predicate="b ∈ DMB"/>
<org.eventb.core.guard name="_jj5McLDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="m ∈ MASTER"/>
<org.eventb.core.guard name="_10GNYLDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(b)"/>
<org.eventb.core.guard name="_UDYcIMyeEeS35eQk3gU39A" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∉ issuedbarrier"/>
<org.eventb.core.guard name="_LIflINasEeS8PrcbdDoUAw" org.eventb.core.label="grd5" org.eventb.core.predicate="p = PROGRAM(m)"/>
<org.eventb.core.guard name="_3TPkcM1UEeS35eQk3gU39A" org.eventb.core.label="grd6" org.eventb.core.predicate="n ∈ dom(p)"/>
<org.eventb.core.guard name="_Zy3egM1OEeS35eQk3gU39A" org.eventb.core.label="grd7" org.eventb.core.predicate="p(n) = b"/>
<org.eventb.core.guard name="_yA9aMM1OEeS35eQk3gU39A" org.eventb.core.comment="all other unissued barriers have a higher position in program order" org.eventb.core.label="grd8" org.eventb.core.predicate="∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ DMB ∧ p(i) ∉ issuedbarrier ⇒ n &lt; i"/>
<org.eventb.core.guard name="_LIgMMNasEeS8PrcbdDoUAw" org.eventb.core.comment="there are no unissued memory accessses before the barrier in program order" org.eventb.core.label="grd9" org.eventb.core.predicate="∀i·i ≠ n ∧ i ∈ dom(p) ∧ p(i) ∈ MEMACCESS ∧ p(i) ∉ issued ⇒ n &lt; i"/>
<org.eventb.core.action name="_SaZ78LDuEeSDLL1FFCt7mQ" org.eventb.core.assignment="ahead ≔ ahead  {b ↦ ({t∣t ∈ issued ∧ m = issuer(t) ∧ m ∉ observers(t)} ∪&#10;                                   {s∣s ∈ dom(observers) ∧ m ∈ observers(s) ∧ (∃o·o ∉ observers(s))})}" org.eventb.core.comment="all memory accesses issued by the master but not observed, together with all the STOREs observed by the master but not observed by all other observers" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_RuxVMMyeEeS35eQk3gU39A" org.eventb.core.assignment="issuedbarrier ≔ issuedbarrier ∪ {b}" org.eventb.core.label="act2"/>
</org.eventb.core.event>
</org.eventb.core.machineFile>
