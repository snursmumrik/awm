<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.comment="This refinement introduces the Data Memory Barrier (DMB)&#10;When a DMB is issued, an ordering is established between the set of stores, observed by the master issuing the DMB&#10;but not observed by all the remaining masters, and the memory accesses after the barrier.&#10;Any master, in the same shareability domain as the master issuing the DMB, observes all the memory accesses ahead&#10;of the DMB  before it observes any of the memory accesses behind the DMB." org.eventb.core.configuration="org.eventb.core.fwd" org.eventb.texttools.text_lastmodified="1427704120043" org.eventb.texttools.text_representation="machine AM4&#10;&#10;// This refinement introduces the Data Memory Barrier (DMB)&#10;// When a DMB is issued, an ordering is established between the set of stores, observed by the master issuing the DMB&#10;// but not observed by all the remaining masters, and the memory accesses after the barrier.&#10;// Any master, in the same shareability domain as the master issuing the DMB, observes all the memory accesses ahead&#10;// of the DMB  before it observes any of the memory accesses behind the DMB.&#10;&#10;refines AM3  sees AC4&#10;&#10;variables issued observed lastobservedvalue observers ahead behind issuedbarrier&#10;&#10;invariants&#10;  @inv1 ahead ∈ DMB ⇸ ℙ(MEMACCESS)        // the set of memory accesses, observed by the master ahead of issuing the DMB&#10;  @inv2 behind ∈ DMB ⇸ ℙ(MEMACCESS)       // the set of memory accesses issued by that master behind the DMB&#10;  @inv3 ∀b·b ∈ DMB ⇒ b ∈ dom(behind)       // all barriers keep track of memory access behind them&#10;  @inv4 issuedbarrier ⊆ DMB&#10;&#10;events&#10;  event INITIALISATION&#10;    then&#10;      @act1 issued ≔ ∅&#10;      @act2 observed ≔ ∅&#10;      @act3 lastobservedvalue ≔ MASTER × {ADDR × {V0}} // initialise each master's view of memory to the default value V0&#10;      @act4 observers ≔ ∅&#10;      @act5 ahead ≔ ∅&#10;      @act6 behind ≔ DMB × {∅}&#10;      @act7 issuedbarrier ≔ ∅&#10;  end&#10;&#10;  event IssueLoad // out of order and the observation of the load is not constrained by a DMB&#10;  refines IssueLoad&#10;    any l&#10;    where&#10;      @grd1 l ∉ issued // not already issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅  // if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {l} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {l ↦ ∅}  // establish the set, initially empty, that will hold the observers of the load&#10;  end&#10;&#10;  event IssueLoadBehindDMB // out of order and the observation of the load is constrained by a DMB&#10;  refines IssueLoad&#10;    any l b&#10;    where&#10;      @grd1 l ∉ issued // not already issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 issuer(b) = issuer(l) // the issuer of the load has issued a barrier&#10;      @grd4 b ∈ dom(ahead)        // and there are stores ahead of the barrier which have&#10;      @grd5 ahead(b) ≠ ∅         // not been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {l} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {l ↦ ∅}  // establish the set, initially empty, that will hold the observers of the load&#10;      @act3 behind(b) ≔ behind(b) ∪ {l}  // load is added to the set of memory accesses behind the barrier&#10;  end&#10;&#10;  event IssueStore // out of order and the observation of the store is not constrained by a DMB&#10;  refines IssueStore&#10;    any s&#10;    where&#10;      @grd1 s ∉ issued // not already issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 ∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅ // if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {s} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {s ↦ ∅} // establish the set, initially empty, that will hold the observers of the store&#10;  end&#10;&#10;  event IssueStoreBehindDMB // out of order and the observation of the store is constrained by a DMB&#10;  refines IssueStore&#10;    any s b&#10;    where&#10;      @grd1 s ∉ issued // not already issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 issuer(b) = issuer(s)  // the issuer of the store has issued a barrier&#10;      @grd4 b ∈ dom(ahead)         // and there are stores ahead of the barrier which have&#10;      @grd5 ahead(b) ≠ ∅          // not been observed&#10;    then&#10;      @act1 issued ≔ issued ∪ {s} // add to the set of issued memory accesses&#10;      @act2 observers ≔ observers  {s ↦ ∅} // establish the set, initially empty, that will hold the observers of the store&#10;      @act3 behind(b) ≔ behind(b) ∪ {s}  // store is added to the set of memory accesses behind the barrier&#10;  end&#10;&#10;  event ObserveLoad // not constrained by a DMB&#10;  refines ObserveLoad&#10;    any l m&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 ∀b·b ∈ dom(ahead) ⇒ l ∉ ahead(b)  // not ahead of a barrier&#10;      @grd6 ∀b·b ∈ dom(behind) ⇒ l ∉ behind(b) // load is not behind any barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;  end&#10;&#10;  event ObserveLoadAheadofDMB // constrained by a DMB - the master issuing the DMB observes loads it has issued before the DMB&#10;  refines ObserveLoad&#10;    any l m b&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l) // the master that issued the load&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 l ∈ ahead(b) //  is ahead of the barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;      @act3 ahead(b) ≔ ahead(b) ∖ {l}  // remove load from ahead set&#10;  end&#10;&#10;  event ObserveLoadBehindDMB // constrained by a DMB: cannot be observed until all stores ahead of the barrier have been observed&#10;  refines ObserveLoad&#10;    any l m b&#10;    where&#10;      @grd1 l ∈ issued // issued&#10;      @grd2 l ∈ LOAD&#10;      @grd3 m = issuer(l)&#10;      @grd4 m ∉ observers(l) // the master has not already observed this load&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 b ∈ dom(behind)&#10;      @grd7 l ∈ behind(b) // load is behind a barrier&#10;      @grd8 ahead(b) = ∅ // all stores ahead of the barrier have been observed&#10;    then&#10;      @act1 observed ≔ observed ∪ {l} // add to the set of observed memory accesses&#10;      @act2 observers(l) ≔ observers(l) ∪ {m} // add to set of masters that have observed this load&#10;  end&#10;&#10;  event ObserveStore // not constrained by a DMB&#10;  refines ObserveStore&#10;    any s m&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 ∀b·b ∈ dom(ahead) ⇒ s ∉ ahead(b)  // not ahead of a barrier&#10;      @grd5 ∀b·b ∈ dom(behind) ⇒ s ∉ behind(b) // not behind a barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m}&#10;  end&#10;&#10;  event ObserveStoreAheadofDMB // constrained by DMB, not all masters have observed the store&#10;  refines ObserveStore&#10;    any s m b o&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 s ∈ ahead(b) // s is ahead of the barrier&#10;      @grd6 o ≠ m&#10;      @grd7 o ∉ observers(s) // there is at least one other master that has not observed this store&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;  end&#10;&#10;  event ObserveStoreLoadAheadofDMB // the master that issued the barrier has issued a LOAD ahead of the barrier that follows this store in observe order&#10;  refines ObserveStore&#10;    any s m b l&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 l ∈ LOAD&#10;      @grd4 m ∉ observers(s) // the master has not already observed this store&#10;      @grd5 b ∈ dom(ahead)&#10;      @grd6 s ∉ ahead(b)  // s is ahead of the barrier&#10;      @grd7 l ∈ ahead(b)&#10;      @grd8 address(l) = address(s)  // s is ahead of the barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;      @act4 ahead(b) ≔ ahead(b) ∪ {s}&#10;  end&#10;&#10;  event ObserveStoreAheadofDMBComplete // constrained by DMB, store is observed by the all the masters&#10;  refines ObserveStore&#10;    any s m b&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 s ∈ ahead(b) // s is ahead of the barrier&#10;      @grd6 ∀o·o ∈ MASTER ∧ o ≠ m ⇒ o ∈ observers(s)  // m is that last master to observe this store&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;      @act4 ahead(b) ≔ ahead(b) ∖ {s} // remove store from ahead set&#10;  end&#10;&#10;  event ObserveStoreBehindDMB // constrained by DMB&#10;  refines ObserveStore&#10;    any s m b&#10;    where&#10;      @grd1 s ∈ issued // issued&#10;      @grd2 s ∈ STORE&#10;      @grd3 m ∉ observers(s) // the master has not already observed this store&#10;      @grd4 b ∈ dom(ahead)&#10;      @grd5 b ∈ dom(behind)&#10;      @grd6 ahead(b) = ∅ // all stores ahead of the barrier have been observed&#10;      @grd7 s ∈ behind(b) // s is behind the barrier&#10;    then&#10;      @act1 observed ≔ observed ∪ {s} // add to the set of observed memory accesses&#10;      @act2 lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)} // update the last observed value for that address for this master&#10;      @act3 observers(s) ≔ observers(s) ∪ {m} // add to set of masters that have observed this store&#10;  end&#10;&#10;  event issueDMB // a master issues a DMB&#10;    any b m&#10;    where&#10;      @grd1 b ∈ DMB&#10;      @grd2 m ∈ MASTER&#10;      @grd3 m = issuer(b)&#10;      @grd4 b ∉ issuedbarrier&#10;    then&#10;      @act1 ahead ≔ ahead  {b ↦ ({t∣t ∈ issued ∧ m = issuer(t) ∧ m ∉ observers(t)} ∪&#10;                                   {s∣s ∈ dom(observers) ∧ m ∈ observers(s) ∧ (∃o·o ∉ observers(s))})} // all memory accesses issued by the master but not observed, together with all the STOREs observed by the master but not observed by all other observers&#10;      @act2 issuedbarrier ≔ issuedbarrier ∪ {b}&#10;  end&#10;end&#10;" version="5">
<org.eventb.core.refinesMachine name="_Y-KCgNauEeS8PrcbdDoUAw" org.eventb.core.target="AM3"/>
<org.eventb.core.seesContext name="_Y-KpkNauEeS8PrcbdDoUAw" org.eventb.core.target="AC4"/>
<org.eventb.core.variable name="(" org.eventb.core.identifier="issued"/>
<org.eventb.core.variable name="_w4qjgLBREeSftfcqDYm3Dx" org.eventb.core.identifier="observed"/>
<org.eventb.core.variable name="_noQRoLBdEeS2YI9ZOZw9XQ" org.eventb.core.identifier="lastobservedvalue"/>
<org.eventb.core.variable name="_-MY0INFSEeSEfrkbRWF-Qw" org.eventb.core.identifier="observers"/>
<org.eventb.core.variable name="_SaT1UrDuEeSDLL1FFCt7mQ" org.eventb.core.identifier="ahead"/>
<org.eventb.core.variable name="_7OyMELD8EeSDLL1FFCt7mQ" org.eventb.core.identifier="behind"/>
<org.eventb.core.variable name="_tR9Z4MydEeS35eQk3gU39A" org.eventb.core.identifier="issuedbarrier"/>
<org.eventb.core.invariant name="_SaUcYLDuEeSDLL1FFCt7mQ" org.eventb.core.comment="the set of memory accesses, observed by the master ahead of issuing the DMB" org.eventb.core.label="inv1" org.eventb.core.predicate="ahead ∈ DMB ⇸ ℙ(MEMACCESS)"/>
<org.eventb.core.invariant name="_7OyMEbD8EeSDLL1FFCt7mQ" org.eventb.core.comment="the set of memory accesses issued by that master behind the DMB" org.eventb.core.label="inv2" org.eventb.core.predicate="behind ∈ DMB ⇸ ℙ(MEMACCESS)"/>
<org.eventb.core.invariant name="_gqA0ALZ6EeSa0vHX1GfqtA" org.eventb.core.comment="all barriers keep track of memory access behind them" org.eventb.core.label="inv3" org.eventb.core.predicate="∀b·b ∈ DMB ⇒ b ∈ dom(behind)"/>
<org.eventb.core.invariant name="_tR9Z4cydEeS35eQk3gU39A" org.eventb.core.label="inv4" org.eventb.core.predicate="issuedbarrier ⊆ DMB"/>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3Dy" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="INITIALISATION">
<org.eventb.core.action name="'" org.eventb.core.assignment="issued ≔ ∅" org.eventb.core.label="act1"/>
<org.eventb.core.action name="(" org.eventb.core.assignment="observed ≔ ∅" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_noQ4sLBdEeS2YI9ZOZw9XQ" org.eventb.core.assignment="lastobservedvalue ≔ MASTER × {ADDR × {V0}}" org.eventb.core.comment="initialise each master's view of memory to the default value V0" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_lW8g4LBeEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers ≔ ∅" org.eventb.core.label="act4"/>
<org.eventb.core.action name="_SaVDcLDuEeSDLL1FFCt7mQ" org.eventb.core.assignment="ahead ≔ ∅" org.eventb.core.label="act5"/>
<org.eventb.core.action name="_7OyzILD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="behind ≔ DMB × {∅}" org.eventb.core.label="act6"/>
<org.eventb.core.action name="_tR-A8MydEeS35eQk3gU39A" org.eventb.core.assignment="issuedbarrier ≔ ∅" org.eventb.core.label="act7"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3Dz" org.eventb.core.comment="out of order and the observation of the load is not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueLoad">
<org.eventb.core.refinesEvent name="_Y-OT8NauEeS8PrcbdDoUAw" org.eventb.core.target="IssueLoad"/>
<org.eventb.core.parameter name="_6jYTQbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.guard name="_5G8aQ7BWEeSftfcqDYm3Dw" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∉ issued"/>
<org.eventb.core.guard name="_5G9BULBWEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_B5KugLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="if the issuer of the load has issued a barrier, the load is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(l) ⇒ ahead(b) = ∅"/>
<org.eventb.core.action name="_5G9BUbBWEeSftfcqDYm3Dw" org.eventb.core.assignment="issued ≔ issued ∪ {l}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_-Me6wNFSEeSEfrkbRWF-Qw" org.eventb.core.assignment="observers ≔ observers  {l ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the load" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_B5T4cLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="out of order and the observation of the load is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueLoadBehindDMB">
<org.eventb.core.refinesEvent name="_Y-PiENauEeS8PrcbdDoUAw" org.eventb.core.target="IssueLoad"/>
<org.eventb.core.parameter name="_6jY6UbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_B5UfgrD_EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_B5Ufg7D_EeSDLL1FFCt7mQ" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∉ issued"/>
<org.eventb.core.guard name="_B5UfhLD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_B5VGkLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the issuer of the load has issued a barrier" org.eventb.core.label="grd3" org.eventb.core.predicate="issuer(b) = issuer(l)"/>
<org.eventb.core.guard name="_B5VGkbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="and there are stores ahead of the barrier which have" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_B5VGkrD_EeSDLL1FFCt7mQ" org.eventb.core.comment="not been observed" org.eventb.core.label="grd5" org.eventb.core.predicate="ahead(b) ≠ ∅"/>
<org.eventb.core.action name="_B5VGk7D_EeSDLL1FFCt7mQ" org.eventb.core.assignment="issued ≔ issued ∪ {l}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_B5VGlLD_EeSDLL1FFCt7mQ" org.eventb.core.assignment="observers ≔ observers  {l ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_-MhXANFSEeSEfrkbRWF-Qw" org.eventb.core.assignment="behind(b) ≔ behind(b) ∪ {l}" org.eventb.core.comment="load is added to the set of memory accesses behind the barrier" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D{" org.eventb.core.comment="out of order and the observation of the store is not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueStore">
<org.eventb.core.refinesEvent name="_Y-RXQNauEeS8PrcbdDoUAw" org.eventb.core.target="IssueStore"/>
<org.eventb.core.parameter name="_6jaIcbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.guard name="_5G9oYrBWEeSftfcqDYm3Dw" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∉ issued"/>
<org.eventb.core.guard name="_5G9oY7BWEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_jNTeIbD-EeSDLL1FFCt7mQ" org.eventb.core.comment="if the issuer of the store has issued a barrier, the store is not constrained by the barrier if all the stores ahead of this barrier have been observed" org.eventb.core.label="grd3" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ∧ issuer(b) = issuer(s) ⇒ ahead(b) = ∅"/>
<org.eventb.core.action name="_5G9oZLBWEeSftfcqDYm3Dw" org.eventb.core.assignment="issued ≔ issued ∪ {s}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_HHecIbBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers ≔ observers  {s ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the store" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_fySasLD8EeSDLL1FFCt7mQ" org.eventb.core.comment="out of order and the observation of the store is constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="IssueStoreBehindDMB">
<org.eventb.core.refinesEvent name="_Y-SlYNauEeS8PrcbdDoUAw" org.eventb.core.target="IssueStore"/>
<org.eventb.core.parameter name="_6javgbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_fyTBwrD8EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_fyTBw7D8EeSDLL1FFCt7mQ" org.eventb.core.comment="not already issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∉ issued"/>
<org.eventb.core.guard name="_fyTBxLD8EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_fyTo0LD8EeSDLL1FFCt7mQ" org.eventb.core.comment="the issuer of the store has issued a barrier" org.eventb.core.label="grd3" org.eventb.core.predicate="issuer(b) = issuer(s)"/>
<org.eventb.core.guard name="_fyTo0bD8EeSDLL1FFCt7mQ" org.eventb.core.comment="and there are stores ahead of the barrier which have" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_fyTo0rD8EeSDLL1FFCt7mQ" org.eventb.core.comment="not been observed" org.eventb.core.label="grd5" org.eventb.core.predicate="ahead(b) ≠ ∅"/>
<org.eventb.core.action name="_fyTo07D8EeSDLL1FFCt7mQ" org.eventb.core.assignment="issued ≔ issued ∪ {s}" org.eventb.core.comment="add to the set of issued memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_fyUP4LD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="observers ≔ observers  {s ↦ ∅}" org.eventb.core.comment="establish the set, initially empty, that will hold the observers of the store" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_7O2dgLD8EeSDLL1FFCt7mQ" org.eventb.core.assignment="behind(b) ≔ behind(b) ∪ {s}" org.eventb.core.comment="store is added to the set of memory accesses behind the barrier" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D|" org.eventb.core.comment="not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoad">
<org.eventb.core.refinesEvent name="_Y-TzgNauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoad"/>
<org.eventb.core.parameter name="_6jb9obErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_l2DF8dFTEeSEfrkbRWF-Qw" org.eventb.core.identifier="m"/>
<org.eventb.core.guard name="_F9cLkbBXEeSftfcqDYm3Dw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_F9cLkrBXEeSftfcqDYm3Dw" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_ZoksANOOEeSWGfl1zVgqXQ" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="__Xjk8LHQEeSNlasBfv989A" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_ve5fENOOEeSWGfl1zVgqXQ" org.eventb.core.comment="not ahead of a barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ⇒ l ∉ ahead(b)"/>
<org.eventb.core.guard name="_ve5fEdOOEeSWGfl1zVgqXQ" org.eventb.core.comment="load is not behind any barrier" org.eventb.core.label="grd6" org.eventb.core.predicate="∀b·b ∈ dom(behind) ⇒ l ∉ behind(b)"/>
<org.eventb.core.action name="_F9cyoLBXEeSftfcqDYm3Dw" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_-MorwNFSEeSEfrkbRWF-Qw" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_QVUigNOPEeSWGfl1zVgqXQ" org.eventb.core.comment="constrained by a DMB - the master issuing the DMB observes loads it has issued before the DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoadAheadofDMB">
<org.eventb.core.refinesEvent name="_Y-VosNauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoad"/>
<org.eventb.core.parameter name="_QVUigtOPEeSWGfl1zVgqXQ" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_QVVJkNOPEeSWGfl1zVgqXQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_s6xgANOPEeSWGfl1zVgqXQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_QVVJkdOPEeSWGfl1zVgqXQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_QVVwoNOPEeSWGfl1zVgqXQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_QVVwodOPEeSWGfl1zVgqXQ" org.eventb.core.comment="the master that issued the load" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="_QVVwotOPEeSWGfl1zVgqXQ" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_QVWXsNOPEeSWGfl1zVgqXQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_s6yuINOPEeSWGfl1zVgqXQ" org.eventb.core.comment="is ahead of the barrier" org.eventb.core.label="grd6" org.eventb.core.predicate="l ∈ ahead(b)"/>
<org.eventb.core.action name="_QVW-wNOPEeSWGfl1zVgqXQ" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_QVW-wdOPEeSWGfl1zVgqXQ" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_s6zVMNOPEeSWGfl1zVgqXQ" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∖ {l}" org.eventb.core.comment="remove load from ahead set" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_8Ii-QLD_EeSDLL1FFCt7mQ" org.eventb.core.comment="constrained by a DMB: cannot be observed until all stores ahead of the barrier have been observed" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveLoadBehindDMB">
<org.eventb.core.refinesEvent name="_Y-Z6INauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveLoad"/>
<org.eventb.core.parameter name="_6jcksbErEeSNbfxw2p-xdg" org.eventb.core.identifier="l"/>
<org.eventb.core.parameter name="_x5RnQdFTEeSEfrkbRWF-Qw" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_8IjlUrD_EeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_8IjlU7D_EeSDLL1FFCt7mQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="l ∈ issued"/>
<org.eventb.core.guard name="_8IjlVLD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_8IkMYLD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(l)"/>
<org.eventb.core.guard name="_8IkMYbD_EeSDLL1FFCt7mQ" org.eventb.core.comment="the master has not already observed this load" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(l)"/>
<org.eventb.core.guard name="_8IkMYrD_EeSDLL1FFCt7mQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_8IkMY7D_EeSDLL1FFCt7mQ" org.eventb.core.label="grd6" org.eventb.core.predicate="b ∈ dom(behind)"/>
<org.eventb.core.guard name="_2bFLcLHLEeStFcxm7qdLvQ" org.eventb.core.comment="load is behind a barrier" org.eventb.core.label="grd7" org.eventb.core.predicate="l ∈ behind(b)"/>
<org.eventb.core.guard name="_ve77UNOOEeSWGfl1zVgqXQ" org.eventb.core.comment="all stores ahead of the barrier have been observed" org.eventb.core.label="grd8" org.eventb.core.predicate="ahead(b) = ∅"/>
<org.eventb.core.action name="_8IkMZLD_EeSDLL1FFCt7mQ" org.eventb.core.assignment="observed ≔ observed ∪ {l}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_-MrvENFSEeSEfrkbRWF-Qw" org.eventb.core.assignment="observers(l) ≔ observers(l) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this load" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_w4qjgLBREeSftfcqDYm3D}" org.eventb.core.comment="not constrained by a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStore">
<org.eventb.core.refinesEvent name="_Y-bvUNauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStore"/>
<org.eventb.core.parameter name="_6jdLwbErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_6jdy0LErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.guard name="_F9cypLBXEeSftfcqDYm3Dw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_Y-cWYNauEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_F9dZsbBXEeSftfcqDYm3Dw" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iaHG4LBfEeS2YI9ZOZw9XQ" org.eventb.core.comment="not ahead of a barrier" org.eventb.core.label="grd4" org.eventb.core.predicate="∀b·b ∈ dom(ahead) ⇒ s ∉ ahead(b)"/>
<org.eventb.core.guard name="_r57_cLDwEeSDLL1FFCt7mQ" org.eventb.core.comment="not behind a barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="∀b·b ∈ dom(behind) ⇒ s ∉ behind(b)"/>
<org.eventb.core.action name="_F9dZsrBXEeSftfcqDYm3Dw" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_Nl7GQLBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iaHt8LBfEeS2YI9ZOZw9XQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_LvROwLDwEeSDLL1FFCt7mQ" org.eventb.core.comment="constrained by DMB, not all masters have observed the store" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreAheadofDMB">
<org.eventb.core.refinesEvent name="_Y-dkgNauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStore"/>
<org.eventb.core.parameter name="_6jeZ4bErEeSNbfxw2p-xdg" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_6jeZ4rErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_LvR10bDwEeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_iX3KMLHKEeStFcxm7qdLvQ" org.eventb.core.identifier="o"/>
<org.eventb.core.guard name="_LvR10rDwEeSDLL1FFCt7mQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_Y-eLkNauEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_LvSc4LDwEeSDLL1FFCt7mQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_LvSc4bDwEeSDLL1FFCt7mQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_LvSc4rDwEeSDLL1FFCt7mQ" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="s ∈ ahead(b)"/>
<org.eventb.core.guard name="_LvSc47DwEeSDLL1FFCt7mQ" org.eventb.core.label="grd6" org.eventb.core.predicate="o ≠ m"/>
<org.eventb.core.guard name="_iX4_YLHKEeStFcxm7qdLvQ" org.eventb.core.comment="there is at least one other master that has not observed this store" org.eventb.core.label="grd7" org.eventb.core.predicate="o ∉ observers(s)"/>
<org.eventb.core.action name="_LvTD8LDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_LvTD8bDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_LvTD8rDwEeSDLL1FFCt7mQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_iYBiQLHKEeStFcxm7qdLvQ" org.eventb.core.comment="constrained by DMB, store is observed by the all the masters" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreAheadofDMBComplete">
<org.eventb.core.refinesEvent name="_Y-fZsNauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStore"/>
<org.eventb.core.parameter name="_iYCJULHKEeStFcxm7qdLvQ" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_iYCJUbHKEeStFcxm7qdLvQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_iYCJUrHKEeStFcxm7qdLvQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_iYCwYLHKEeStFcxm7qdLvQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_Y-gAwNauEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_iYCwYbHKEeStFcxm7qdLvQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iYDXcLHKEeStFcxm7qdLvQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_iYDXcbHKEeStFcxm7qdLvQ" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd5" org.eventb.core.predicate="s ∈ ahead(b)"/>
<org.eventb.core.guard name="_iYD-gLHKEeStFcxm7qdLvQ" org.eventb.core.comment="m is that last master to observe this store" org.eventb.core.label="grd6" org.eventb.core.predicate="∀o·o ∈ MASTER ∧ o ≠ m ⇒ o ∈ observers(s)"/>
<org.eventb.core.action name="_iYFMoLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_iYFzsLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iYGawLHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_iYHB0LHKEeStFcxm7qdLvQ" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∖ {s}" org.eventb.core.comment="remove store from ahead set" org.eventb.core.label="act4"/>
</org.eventb.core.event>
<org.eventb.core.event name="_iYHo4LHKEeStFcxm7qdLvQ" org.eventb.core.comment="constrained by DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreBehindDMB">
<org.eventb.core.refinesEvent name="_Y-hO4NauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStore"/>
<org.eventb.core.parameter name="_iYIP8bHKEeStFcxm7qdLvQ" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_iYI3ALHKEeStFcxm7qdLvQ" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_iYI3AbHKEeStFcxm7qdLvQ" org.eventb.core.identifier="b"/>
<org.eventb.core.guard name="_iYI3ArHKEeStFcxm7qdLvQ" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_Y-h18NauEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_iYJeELHKEeStFcxm7qdLvQ" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd3" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_iYJeEbHKEeStFcxm7qdLvQ" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_iYKFILHKEeStFcxm7qdLvQ" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(behind)"/>
<org.eventb.core.guard name="_iYKFIbHKEeStFcxm7qdLvQ" org.eventb.core.comment="all stores ahead of the barrier have been observed" org.eventb.core.label="grd6" org.eventb.core.predicate="ahead(b) = ∅"/>
<org.eventb.core.guard name="_iYKsMLHKEeStFcxm7qdLvQ" org.eventb.core.comment="s is behind the barrier" org.eventb.core.label="grd7" org.eventb.core.predicate="s ∈ behind(b)"/>
<org.eventb.core.action name="_iYLTQbHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_iYL6ULHKEeStFcxm7qdLvQ" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_iYL6UbHKEeStFcxm7qdLvQ" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
</org.eventb.core.event>
<org.eventb.core.event name="_SaZU4LDuEeSDLL1FFCt7mQ" org.eventb.core.comment="a master issues a DMB" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="issueDMB">
<org.eventb.core.parameter name="_jj4lYLDuEeSDLL1FFCt7mQ" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_6jg2ILErEeSNbfxw2p-xdg" org.eventb.core.identifier="m"/>
<org.eventb.core.guard name="_SaZU4rDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd1" org.eventb.core.predicate="b ∈ DMB"/>
<org.eventb.core.guard name="_jj5McLDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd2" org.eventb.core.predicate="m ∈ MASTER"/>
<org.eventb.core.guard name="_10GNYLDuEeSDLL1FFCt7mQ" org.eventb.core.label="grd3" org.eventb.core.predicate="m = issuer(b)"/>
<org.eventb.core.guard name="_tSHx8MydEeS35eQk3gU39A" org.eventb.core.label="grd4" org.eventb.core.predicate="b ∉ issuedbarrier"/>
<org.eventb.core.action name="_SaZ78LDuEeSDLL1FFCt7mQ" org.eventb.core.assignment="ahead ≔ ahead  {b ↦ ({t∣t ∈ issued ∧ m = issuer(t) ∧ m ∉ observers(t)} ∪&#10;                                   {s∣s ∈ dom(observers) ∧ m ∈ observers(s) ∧ (∃o·o ∉ observers(s))})}" org.eventb.core.comment="all memory accesses issued by the master but not observed, together with all the STOREs observed by the master but not observed by all other observers" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_tSHx8cydEeS35eQk3gU39A" org.eventb.core.assignment="issuedbarrier ≔ issuedbarrier ∪ {b}" org.eventb.core.label="act2"/>
</org.eventb.core.event>
<org.eventb.core.event name="_Y-kSMNauEeS8PrcbdDoUAw" org.eventb.core.comment="the master that issued the barrier has issued a LOAD ahead of the barrier that follows this store in observe order" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.label="ObserveStoreLoadAheadofDMB">
<org.eventb.core.refinesEvent name="_Y-kSMdauEeS8PrcbdDoUAw" org.eventb.core.target="ObserveStore"/>
<org.eventb.core.parameter name="_Y-kSMtauEeS8PrcbdDoUAw" org.eventb.core.identifier="s"/>
<org.eventb.core.parameter name="_Y-k5QNauEeS8PrcbdDoUAw" org.eventb.core.identifier="m"/>
<org.eventb.core.parameter name="_Y-k5QdauEeS8PrcbdDoUAw" org.eventb.core.identifier="b"/>
<org.eventb.core.parameter name="_Y-k5QtauEeS8PrcbdDoUAw" org.eventb.core.identifier="l"/>
<org.eventb.core.guard name="_Y-k5Q9auEeS8PrcbdDoUAw" org.eventb.core.comment="issued" org.eventb.core.label="grd1" org.eventb.core.predicate="s ∈ issued"/>
<org.eventb.core.guard name="_Y-k5RNauEeS8PrcbdDoUAw" org.eventb.core.label="grd2" org.eventb.core.predicate="s ∈ STORE"/>
<org.eventb.core.guard name="_Y-lgUNauEeS8PrcbdDoUAw" org.eventb.core.label="grd3" org.eventb.core.predicate="l ∈ LOAD"/>
<org.eventb.core.guard name="_Y-lgUdauEeS8PrcbdDoUAw" org.eventb.core.comment="the master has not already observed this store" org.eventb.core.label="grd4" org.eventb.core.predicate="m ∉ observers(s)"/>
<org.eventb.core.guard name="_Y-lgUtauEeS8PrcbdDoUAw" org.eventb.core.label="grd5" org.eventb.core.predicate="b ∈ dom(ahead)"/>
<org.eventb.core.guard name="_Y-lgU9auEeS8PrcbdDoUAw" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd6" org.eventb.core.predicate="s ∉ ahead(b)"/>
<org.eventb.core.guard name="_Y-mHYNauEeS8PrcbdDoUAw" org.eventb.core.label="grd7" org.eventb.core.predicate="l ∈ ahead(b)"/>
<org.eventb.core.guard name="_Y-mHYdauEeS8PrcbdDoUAw" org.eventb.core.comment="s is ahead of the barrier" org.eventb.core.label="grd8" org.eventb.core.predicate="address(l) = address(s)"/>
<org.eventb.core.action name="_Y-mHYtauEeS8PrcbdDoUAw" org.eventb.core.assignment="observed ≔ observed ∪ {s}" org.eventb.core.comment="add to the set of observed memory accesses" org.eventb.core.label="act1"/>
<org.eventb.core.action name="_Y-mHY9auEeS8PrcbdDoUAw" org.eventb.core.assignment="lastobservedvalue(m) ≔ lastobservedvalue(m)  {address(s) ↦ value(s)}" org.eventb.core.comment="update the last observed value for that address for this master" org.eventb.core.label="act2"/>
<org.eventb.core.action name="_Y-mucNauEeS8PrcbdDoUAw" org.eventb.core.assignment="observers(s) ≔ observers(s) ∪ {m}" org.eventb.core.comment="add to set of masters that have observed this store" org.eventb.core.label="act3"/>
<org.eventb.core.action name="_Y-mucdauEeS8PrcbdDoUAw" org.eventb.core.assignment="ahead(b) ≔ ahead(b) ∪ {s}" org.eventb.core.label="act4"/>
</org.eventb.core.event>
</org.eventb.core.machineFile>
